% =========================================================
\chapter{모듈(Module)}

지금까지는 하나의 파일 안에서
조건문, 반복문, 함수 등을 사용해 프로그램을 작성했습니다.
이 방식은 작은 프로그램에서는 충분히 효과적이지만,
프로그램의 규모가 커질수록 여러 한계에 부딪히게 됩니다.

대표적으로 다음과 같은 문제가 발생합니다.

\begin{itemize}
  \item 동일한 기능을 여러 파일이나 프로젝트에서 다시 사용하고 싶을 때, 코드를 복사해서 붙여 넣게 된다
  \item 하나의 파일에 코드가 계속 쌓이면서 구조를 파악하거나 수정하기가 점점 어려워진다
  \item 팀 프로젝트에서 역할을 나누어 개발하고 싶어도, 파일이 하나라 분업이 어렵다
\end{itemize}

이러한 문제를 해결하기 위해 등장한 개념이 바로 \textbf{모듈(module)}입니다.

\begin{conceptbox}
\textbf{모듈(module)}이란
\textbf{함수, 변수, 클래스, 실행 문장 등을 하나로 묶어 둔}
\textbf{\texttt{.py} 확장자를 가진 파이썬 파일}을 의미합니다.
즉, 모듈은 코드를 파일 단위로 분리하여
\textbf{관리성과 재사용성을 높이기 위한 기본 단위}입니다.
\end{conceptbox}

% ---------------------------------------------------------
\section{모듈을 왜 사용할까요?}

파이썬 인터프리터에서 직접 입력한 코드나,
하나의 파일로 작성된 프로그램은
실행이 끝나면 메모리에서 사라집니다.
따라서 실제 개발에서는
대부분 코드를 파일 형태로 저장하고 실행합니다.

이렇게 파일로 작성되어 실행되는 파이썬 프로그램을
\textbf{스크립트(script)}라고 부릅니다.

\begin{conceptbox}
\textbf{스크립트(script)}란
파이썬 인터프리터에 명령을 한 줄씩 입력하는 대신,
\textbf{파일로 작성하여 실행하는 파이썬 프로그램}을 말합니다.
VS Code에서 \texttt{.py} 파일을 작성해 실행하는 방식이
대표적인 스크립트 실행 방식입니다.
\end{conceptbox}

하지만 스크립트 하나에 모든 코드를 작성하면,
프로그램이 커질수록 다음과 같은 불편이 생깁니다.

\begin{itemize}
  \item 특정 기능만 수정하고 싶은데, 파일 전체를 이해해야 한다
  \item 자주 사용하는 함수를 다른 프로그램에서도 쓰고 싶어진다
  \item 테스트 코드와 실제 기능 코드가 뒤섞이기 쉽다
\end{itemize}

이때 코드를 여러 파일로 나누고,
필요한 부분만 불러와 사용하는 방식이 바로 \textbf{모듈}입니다.
모듈을 사용하면 코드의 구조가 명확해지고,
기능 단위로 재사용이 가능해집니다.

% ---------------------------------------------------------
\section{내가 만든 모듈 만들기: \texttt{.py} 파일}

모듈은 특별한 문법이 필요한 개념이 아닙니다.
단순히 \texttt{.py} 파일 하나가 곧 모듈입니다.

예를 들어 같은 폴더에
\texttt{fibo.py}라는 파일을 만들고
다음과 같이 작성해 보겠습니다.

\begin{examplebox}
\begin{lstlisting}
# fibo.py

def fib(n):
    a, b = 0, 1
    while a < n:
        print(a, end=" ")
        a, b = b, a + b
    print()

def fib2(n):
    result = []
    a, b = 0, 1
    while a < n:
        result.append(a)
        a, b = b, a + b
    return result
\end{lstlisting}
\end{examplebox}

이 파일에는 두 개의 함수가 정의되어 있습니다.

\begin{itemize}
  \item \texttt{fib(n)}: 특정 값보다 작은 피보나치 수를 화면에 출력
  \item \texttt{fib2(n)}: 피보나치 수를 리스트로 만들어 반환
\end{itemize}

이제 이 파일은 단순한 코드 묶음이 아니라,
다른 파일에서 불러와 사용할 수 있는 \textbf{모듈}이 됩니다.

\begin{notebox}
\texttt{fib} 함수의 마지막 \texttt{print()}는
출력 후 줄바꿈을 위해 사용됩니다.
이로 인해 출력이 끝난 뒤 커서는 다음 줄로 이동합니다.
\end{notebox}

% ---------------------------------------------------------
\section{\texttt{import}로 모듈 불러오기}

\subsection{\texttt{import module\_name}}

\texttt{import fibo}를 실행하면,
파이썬은 \texttt{fibo.py} 파일을 찾아 로드하고,
그 안에 정의된 모든 이름을
\textbf{\texttt{fibo}라는 하나의 공간(namespace)} 안에 넣습니다.

\begin{examplebox}
\begin{lstlisting}
import fibo

fibo.fib(30)
print(fibo.fib2(30))
\end{lstlisting}

출력 결과(예시):
\begin{verbatim}
0 1 1 2 3 5 8 13 21

[0, 1, 1, 2, 3, 5, 8, 13, 21]
\end{verbatim}
\end{examplebox}

여기서 중요한 점은,
\texttt{fib}와 \texttt{fib2}가
현재 파일의 이름 공간으로 직접 들어오지 않는다는 것입니다.
오직 \texttt{fibo}라는 이름만 생성되고,
그 아래에서 점(\texttt{.})을 이용해 접근합니다.

이 방식은 이름 충돌을 방지하고,
어떤 함수가 어느 모듈에서 왔는지를
코드만 보고도 쉽게 파악할 수 있게 해 줍니다.

\subsection{자주 쓰는 함수는 지역 이름에 연결하기}

모듈을 \texttt{import}하면,
모듈 안에 정의된 함수들은
기본적으로 \texttt{module\_name.function\_name} 형태로 사용합니다.
이 방식은 함수의 출처를 명확히 보여 준다는 장점이 있지만,
같은 함수를 여러 번 호출해야 하는 경우에는
표현이 다소 길어질 수 있습니다.

이럴 때는
모듈 안의 함수를
현재 파일에서 사용할 \textbf{지역 이름(local name)}에
연결하여 사용할 수 있습니다.

\begin{examplebox}
\begin{lstlisting}
import fibo

fib = fibo.fib
fib(50)
\end{lstlisting}

출력 결과(예시):
\begin{verbatim}
0 1 1 2 3 5 8 13 21 34
\end{verbatim}
\end{examplebox}

위 코드에서
\texttt{fib = fibo.fib}는
\texttt{fibo.fib} 함수를 새로운 이름 \texttt{fib}에 연결하는 문장입니다.
새로운 함수를 정의하는 것이 아니라,
이미 존재하는 함수를
더 짧은 이름으로 한 번 더 가리키는 것에 해당합니다.

따라서
\texttt{fib(50)}과 \texttt{fibo.fib(50)}은
\textbf{완전히 동일한 동작}을 수행합니다.

% ---------------------------------------------------------
\section{\texttt{from}을 이용한 다양한 import}

\subsection{\texttt{from module import name}}

모듈 전체가 아니라,
특정 이름만 선택적으로 가져올 수도 있습니다.

\begin{examplebox}
\begin{lstlisting}
from fibo import fib, fib2

fib(30)
print(fib2(30))
\end{lstlisting}

출력 결과(예시):
\begin{verbatim}
0 1 1 2 3 5 8 13 21

[0, 1, 1, 2, 3, 5, 8, 13, 21]
\end{verbatim}
\end{examplebox}

이 방식에서는 \texttt{fibo}라는 이름이 생성되지 않고,
지정한 이름들이 현재 공간으로 직접 들어옵니다.

\begin{notebox}
이 방식은 코드가 짧아지는 장점이 있지만,
어떤 모듈에서 온 함수인지 코드만 보고는
바로 알기 어려울 수 있습니다.
\end{notebox}

\subsection{\texttt{import ... as ...}: 별명 사용}

모듈 이름이나 함수 이름이 길거나,
여러 번 반복해서 사용해야 하는 경우에는
\textbf{별명(alias)}을 붙여 더 짧은 이름으로 사용할 수 있습니다.
별명을 사용해도
모듈이나 함수의 동작 자체는 변하지 않습니다.

\begin{examplebox}
\begin{lstlisting}
import fibo as fb

fb.fib(30)
\end{lstlisting}

출력 결과(예시):
\begin{verbatim}
0 1 1 2 3 5 8 13 21
\end{verbatim}
\end{examplebox}

위 예제에서
\texttt{fb}는 \texttt{fibo} 모듈을 가리키는 새로운 이름입니다.
따라서
\texttt{fb.fib(30)}과 \texttt{fibo.fib(30)}은
완전히 동일하게 동작합니다.

또는, 모듈 전체가 아니라,
특정 함수나 변수에만 별명을 붙일 수도 있습니다.

\begin{examplebox}
\begin{lstlisting}
from fibo import fib as fibonacci

fibonacci(30)
\end{lstlisting}

출력 결과(예시):
\begin{verbatim}
0 1 1 2 3 5 8 13 21
\end{verbatim}
\end{examplebox}

이 경우에는
\texttt{fib} 함수만 가져와
\texttt{fibonacci}라는 이름으로 사용하게 됩니다.
모듈 이름 \texttt{fibo}는
현재 이름 공간에 생성되지 않습니다.

\begin{notebox}
별명은
코드를 더 읽기 쉽게 만들거나,
이름 충돌을 피하기 위해 자주 사용됩니다.
특히 여러 모듈에서 비슷한 이름의 함수가 등장할 때
별명을 사용하는 습관이 도움이 됩니다.
\end{notebox}

% ---------------------------------------------------------
\section{\texttt{from module import *}}

\texttt{from fibo import *}와 같이 작성하면,
모듈 안에 정의된 대부분의 이름이
현재 파일의 이름 공간으로 한꺼번에 추가됩니다.
이 방식은 코드가 짧아진다는 장점이 있지만,
여러 가지 문제를 함께 가져올 수 있습니다.

대표적인 문제점은 다음과 같습니다.

\begin{itemize}
  \item 이미 사용 중이던 변수나 함수 이름이
        의도치 않게 덮어쓰여
        예기치 않은 동작을 일으킬 수 있습니다
  \item 어떤 이름이 어느 모듈에서 왔는지
        코드만 보고는 파악하기 어렵습니다
  \item IDE의 자동 완성 기능이나
        오류 발생 시 디버깅 과정이 불편해질 수 있습니다
\end{itemize}

이러한 이유로,
\texttt{from module import *} 방식은
학습용 예제나 매우 제한적인 상황을 제외하면
\textbf{권장되지 않습니다}.

일반적으로는
\texttt{import module\_name} 또는
\texttt{from module import name}처럼
가져오는 이름을 명확히 드러내는 방식을 사용하는 것이
코드의 가독성과 안정성을 높이는 데 도움이 됩니다.

% ---------------------------------------------------------
\section{\texttt{\_\_name\_\_}과 모듈 실행 방식}

하나의 \texttt{.py} 파일은
다음 두 가지 방식으로 사용될 수 있습니다.

\begin{itemize}
  \item 다른 파일에서 \texttt{import}하여 기능을 가져오는 경우
  \item 파일 자체를 직접 실행하는 경우
\end{itemize}

이 두 상황을 구분하기 위해,
파이썬은 모든 모듈에 대해
\texttt{\_\_name\_\_}이라는 특별한 변수를 자동으로 제공합니다.

\begin{conceptbox}
\texttt{\_\_name\_\_}의 값은
파일이 어떻게 사용되었는지에 따라 다음과 같이 결정됩니다.
\begin{itemize}
  \item 다른 파일에서 import된 경우:
        해당 모듈의 이름
  \item 파일이 직접 실행된 경우:
        \texttt{"\_\_main\_\_"}
\end{itemize}
\end{conceptbox}

이 성질을 이용하면,
하나의 파일을
\textbf{모듈로도 사용하고 스크립트로도 사용할 수 있도록}
작성할 수 있습니다.
이를 위해 다음과 같은 패턴이 자주 사용됩니다.

\begin{examplebox}
\begin{lstlisting}
# fibo.py

def fib(n):
    a, b = 0, 1
    while a < n:
        print(a, end=" ")
        a, b = b, a + b
    print()

def fib2(n):
    result = []
    a, b = 0, 1
    while a < n:
        result.append(a)
        a, b = b, a + b
    return result

if __name__ == "__main__":
    print(fib2(50))
\end{lstlisting}
\end{examplebox}

위 코드가
\textbf{직접 실행될 때}와
\textbf{다른 파일에서 import될 때}의 동작은 서로 다릅니다.

\subsection*{파일을 직접 실행한 경우}

터미널에서 다음과 같이 실행하면,
\texttt{\_\_name\_\_}의 값이 \texttt{"\_\_main\_\_"}이 되어
조건문 아래의 코드가 실행됩니다.

\begin{examplebox}
\begin{lstlisting}
    python3 fibo.py
\end{lstlisting}

출력 결과(예시):
\begin{verbatim}
[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
\end{verbatim}
\end{examplebox}

\begin{notebox}
터미널에서 파이썬 파일을 실행하는 명령은
환경에 따라 다를 수 있습니다.
일부 환경에서는 \texttt{python} 명령이
Python 2를 가리킬 수 있으므로,
Python 3를 명확히 사용하기 위해
\texttt{python3} 명령을 사용하는 것이 안전합니다.
Windows 환경에서는 보통 \texttt{python} 명령이
Python 3를 가리킵니다.
\end{notebox}

\subsection*{다른 파일에서 import한 경우}

다음과 같은 파일이 있다고 가정해 봅시다.

\begin{examplebox}
\begin{lstlisting}
# main.py
import fibo

fibo.fib(30)
\end{lstlisting}

출력 결과(예시):
\begin{verbatim}
0 1 1 2 3 5 8 13 21
\end{verbatim}
\end{examplebox}

이 경우,
\texttt{fibo.py}는 import되어 사용되므로
\texttt{if \_\_name\_\_ == "\_\_main\_\_":} 아래의 코드는
실행되지 않습니다.

\begin{notebox}
이 패턴을 사용하면
모듈을 import할 때는
불필요한 출력 없이
함수와 변수만 안전하게 제공할 수 있고,
파일을 직접 실행했을 때만
테스트 코드나 예제 코드를 실행할 수 있습니다.
\end{notebox}

% ---------------------------------------------------------
\section{모듈 검색 경로: \texttt{sys.path}}

파이썬에서 \texttt{import} 문이 실행되면,
인터프리터는 해당 이름의 모듈을
정해진 순서에 따라 차례대로 탐색합니다.
이때 사용되는 검색 경로의 목록이
\texttt{sys.path}입니다.

\begin{conceptbox}
\texttt{sys.path}는
파이썬이 모듈을 찾기 위해 순서대로 검사하는
디렉터리 경로들의 리스트입니다.
\end{conceptbox}

\subsection*{모듈 탐색 순서}

예를 들어,
\texttt{import spam}이라는 문장이 실행되면
파이썬은 다음과 같은 순서로 모듈을 찾습니다.

\begin{itemize}
  \item 먼저 동일한 이름의 \textbf{내장 모듈}이 있는지 확인합니다
  \item 내장 모듈이 없다면,
        \texttt{sys.path}에 등록된 디렉터리들을
        앞에서부터 차례대로 탐색합니다
  \item 각 디렉터리에서
        \texttt{spam.py} (또는 패키지 형태)를 찾습니다
\end{itemize}

내장 모듈의 목록은
\texttt{sys.builtin\_module\_names}에 저장되어 있으며,
이들은 파일 탐색 없이 바로 로드됩니다.

\subsection*{\texttt{sys.path}의 초기 구성}

프로그램이 시작될 때,
\texttt{sys.path}는 다음과 같은 경로들로 초기화됩니다.

\begin{itemize}
  \item 현재 실행 중인 스크립트가 위치한 디렉터리
        (또는 대화형 인터프리터의 경우 현재 작업 디렉터리)
  \item 환경 변수 \texttt{PYTHONPATH}에 등록된 디렉터리들
  \item 파이썬 설치 시 설정된 기본 경로
        (일반적으로 \texttt{site-packages} 디렉터리를 포함)
\end{itemize}

이 순서 때문에,
현재 스크립트가 있는 디렉터리는
표준 라이브러리보다 먼저 검색됩니다.
즉,
같은 이름의 파일이 있을 경우
표준 라이브러리보다
현재 디렉터리의 파일이 먼저 로드됩니다.

\begin{examplebox}
\begin{lstlisting}
import sys
print(sys.path)
\end{lstlisting}
\end{examplebox}

위 코드를 실행하면,
현재 파이썬 인터프리터가
어떤 경로들을 기준으로 모듈을 찾고 있는지
확인할 수 있습니다.

\begin{notebox}
이러한 검색 순서로 인해,
표준 라이브러리와 같은 이름의 파일을
현재 디렉터리에 만들면
의도치 않은 모듈이 로드될 수 있습니다.
이 경우는 보통 오류의 원인이 됩니다.
\end{notebox}

% ---------------------------------------------------------
\subsection*{컴파일된 파이썬 파일과 \texttt{\_\_pycache\_\_}}

모듈을 더 빠르게 로드하기 위해,
파이썬은 모듈을 처음 불러올 때
해당 소스를 바이트코드 형태로 컴파일하여
\texttt{\_\_pycache\_\_} 디렉터리에 저장합니다.
이 파일의 확장자는 \texttt{.pyc}입니다.

컴파일된 파일의 이름에는
사용 중인 파이썬 구현과 버전 정보가 포함되어,
서로 다른 파이썬 버전의 결과물이
같은 디렉터리에 공존할 수 있습니다.

\begin{notebox}
\texttt{.pyc} 파일은
프로그램의 실행 속도를 빠르게 만드는 것이 아니라,
\textbf{모듈을 불러오는 속도}를 개선하기 위한 캐시입니다.
소스 코드의 수정 여부는
자동으로 검사되며,
필요할 경우 다시 컴파일됩니다.
\end{notebox}

일반적인 사용 환경에서는
이 과정이 완전히 자동으로 처리되므로,
사용자가 직접 관리할 필요는 없습니다.

% ---------------------------------------------------------
\section{모듈의 구성 확인: \texttt{dir()}}

모듈을 import한 뒤,
그 안에 어떤 이름들이 정의되어 있는지 알고 싶을 때
\texttt{dir()} 함수를 사용할 수 있습니다.

\texttt{dir()}는
객체가 제공하는 이름들을
\textbf{문자열의 리스트 형태로 정렬하여 반환}합니다.

\subsection*{모듈에 대해 \texttt{dir()} 사용하기}

다음은
\texttt{fibo} 모듈에 정의된 이름들을 확인하는 예시입니다.

\begin{examplebox}
\begin{lstlisting}
import fibo
print(dir(fibo))
\end{lstlisting}

출력 결과(예시):
\begin{verbatim}
['__name__', 'fib', 'fib2']
\end{verbatim}
\end{examplebox}

이 결과를 통해,
\texttt{fibo} 모듈이
\texttt{fib}, \texttt{fib2}라는 함수와
몇 가지 특수한 이름들을 제공하고 있음을 알 수 있습니다.

이처럼 \texttt{dir()}는
모듈이 외부에 공개하는 구성 요소를
빠르게 확인할 수 있는 도구입니다.

\subsection*{인자를 주지 않은 경우}

\texttt{dir()}에 인자를 전달하지 않으면,
현재 이름 공간에 정의된 이름들을 나열합니다.

\begin{examplebox}
\begin{lstlisting}
a = [1, 2, 3, 4, 5]
import fibo
fib = fibo.fib
print(dir())
\end{lstlisting}

출력 결과(예시):
\begin{verbatim}
['__builtins__', '__name__', 'a', 'fib', 'fibo']
\end{verbatim}
\end{examplebox}

이 결과에는
변수, 함수, 모듈 등
현재 사용 가능한 모든 이름이 함께 포함됩니다.
즉,
\texttt{dir()}는
특정 종류의 객체만이 아니라
\textbf{모든 종류의 이름을 나열한다}는 점에 주의해야 합니다.

\subsection*{내장 이름 확인하기}

\texttt{dir()}는
기본적으로 내장 함수와 예외들의 이름을
직접 보여 주지는 않습니다.
이러한 이름들은
\texttt{builtins} 모듈에 정의되어 있습니다.

\begin{examplebox}
\begin{lstlisting}
import builtins
print(dir(builtins))
\end{lstlisting}

출력 결과(예시):
\begin{verbatim}
['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException',
 'Exception', 'False', 'True', 'int', 'list', 'print', 'range', 'str', ...]
\end{verbatim}
\end{examplebox}

\begin{notebox}
\texttt{dir()}는
객체가 제공하는 이름들을 탐색하는 용도로 사용됩니다.
실제 기능이나 동작을 설명해 주지는 않으므로,
구체적인 사용법은
공식 문서나 \texttt{help()} 함수와 함께 확인하는 것이 좋습니다.
\end{notebox}

% ---------------------------------------------------------
\section{외부 모듈 사용하기}

지금까지는
직접 만든 \texttt{.py} 파일을 모듈로 사용하는 방법을 살펴보았습니다.
하지만 파이썬의 가장 큰 장점 중 하나는
이미 잘 만들어진 \textbf{외부 모듈을 매우 쉽게 사용할 수 있다는 점}입니다.

외부 모듈은 크게 두 종류로 나눌 수 있습니다.

\begin{itemize}
  \item 파이썬을 설치하면 기본으로 제공되는 \textbf{표준 라이브러리}
  \item 사용자가 추가로 설치해서 사용하는 \textbf{서드파티(third-party) 모듈}
\end{itemize}

% ---------------------------------------------------------
\subsection{표준 라이브러리(Standard Library)}

\textbf{표준 라이브러리}는
파이썬을 설치할 때 함께 제공되는
기본 모듈들의 집합입니다.
따라서 별도의 설치 과정 없이
바로 \texttt{import}하여 사용할 수 있습니다.

표준 라이브러리는
수학 계산, 난수 생성, 파일 처리, 운영체제 제어 등
자주 사용되는 기능들을 폭넓게 제공합니다.

대표적인 표준 라이브러리 예시는 다음과 같습니다.

\begin{itemize}
  \item \texttt{math}: 수학 함수 제공
  \item \texttt{random}: 난수 생성
  \item \texttt{sys}: 파이썬 인터프리터 관련 정보
  \item \texttt{os}: 운영체제 기능 접근
\end{itemize}

\begin{examplebox}
\begin{lstlisting}
import math

print(math.sqrt(16))
print(math.pi)
\end{lstlisting}

출력 결과(예시):
\begin{verbatim}
4.0
3.141592653589793
\end{verbatim}
\end{examplebox}

\begin{examplebox}
\begin{lstlisting}
import random

print(random.randint(1, 10))
print(random.choice([1, 2, 3, 4]))
\end{lstlisting}

출력 결과(예시):
\begin{verbatim}
7
3
\end{verbatim}
\end{examplebox}

\begin{notebox}
표준 라이브러리는
\texttt{sys.path}에 자동으로 포함된 경로에 위치하므로,
추가 설치 없이 바로 import할 수 있습니다.
출력 결과 중 난수는 실행할 때마다 달라질 수 있습니다.
\end{notebox}

\begin{notebox}
표준 라이브러리 외에도,
다른 개발자들이 만들어 공개한
다양한 외부 모듈들이 존재합니다.
이러한 모듈들은 보통
패키지 관리 도구를 통해 설치하여 사용하며,
이에 대해서는 이후
패키지 챕터에서 자세히 다룹니다.
\end{notebox}

\begin{readernotebox}
모듈 단원의 핵심 개념을 스스로 점검해 보세요.
\begin{itemize}
  \item \texttt{import module} 방식과
        \texttt{from module import name} 방식은
        이름을 사용하는 방법에서 어떤 차이가 있나요?
  \vspace{0.6cm}

  \item \texttt{import module as alias}와 같이
        별명을 사용하는 이유는 무엇인가요?
        어떤 상황에서 특히 유용할까요?
  \vspace{0.6cm}

  \item 같은 \texttt{.py} 파일이라도
        \texttt{import}될 때와
        직접 실행될 때
        동작이 달라지는 이유는 무엇인가요?
  \vspace{0.6cm}

  \item 파이썬은 모듈을 import할 때
        어떤 순서로 모듈을 찾나요?
        이 과정에서 \texttt{sys.path}는
        어떤 역할을 하나요?
  \vspace{0.6cm}

  \item \texttt{dir()} 함수는
        언제, 어떤 목적으로 사용하는 것이 적절한가요?
\end{itemize}
\end{readernotebox}
