% =========================================================
\section{예외 심화}

앞선 섹션에서는 이미 발생한 예외를 ``처리하는 방법''을 배웠습니다.
이번 섹션에서는 한 단계 더 나아가
\textbf{예외를 직접 발생시키고},
\textbf{사용자 정의 예외를 만들며},
\textbf{예외의 구조를 이해하는 방법}을 다룹니다.

즉, 이번에는 단순히 예외를 ``잡는 것''이 아니라,
프로그램의 흐름을 \textbf{설계하기 위한 도구로서 예외를 사용하는 방법}을 배우게 됩니다.

\begin{notebox}
예외는 단순한 오류 메시지가 아닙니다.
프로그램의 비정상적인 상태를
``의도적으로 표현하는 수단''이기도 합니다.
\end{notebox}

% ---------------------------------------------------------
\subsection{예외 직접 발생시키기: \texttt{raise}}

파이썬에서는 \texttt{raise} 키워드를 사용하여
예외를 직접 발생시킬 수 있습니다.

즉, 단순히 ``오류가 발생했을 때 처리하는 것''이 아니라,
\textbf{특정 조건에서 의도적으로 예외를 발생시킬 수 있습니다.}

raise의 기본 사용법은 다음과 같습니다.

\begin{examplebox}
\begin{lstlisting}
raise Exception("Message")
\end{lstlisting}
\end{examplebox}

여기서

\begin{itemize}
  \item \texttt{Exception}은 발생시킬 예외의 종류(예외 클래스)
  \item \texttt{"Message"}는 예외에 대한 설명 메시지
\end{itemize}

를 의미합니다.

\begin{notebox}
\texttt{Exception}은 가장 일반적인 예외 클래스입니다.
실제 코드에서는 가능한 한
\textbf{구체적인 예외 타입을 사용하는 것이 좋습니다.}
\end{notebox}

다음 예시를 살펴보겠습니다.

\begin{examplebox}
\begin{lstlisting}
def divide(a, b):
    if b == 0:
        raise ValueError("Denominator cannot be zero.")
    return a / b

print(divide(10, 2))
\end{lstlisting}
\end{examplebox}

이 코드에서는 분모가 0이면 정상적인 계산이 불가능하므로 \texttt{ValueError}를 직접 발생시킵니다.

\texttt{ValueError}는
``값이 적절하지 않다''는 의미를 갖는 예외입니다.
따라서 이 상황에 더 적합합니다.

\texttt{raise}는
``지금 이 상황은 정상적인 흐름이 아니다''라고
명시적으로 알리는 역할을 합니다.

이는 함수의 사용 조건을 강제하는 강력한 방법입니다.

\begin{notebox}
예외를 발생시키는 것은
``프로그램을 멈추기 위한 것''이 아니라,
\textbf{잘못된 상태가 더 진행되지 않도록 막는 안전 장치}입니다.
\end{notebox}

% ---------------------------------------------------------
\subsection{예외 다시 발생시키기 (re-raise)}

예외를 한 번 잡은 뒤,
다시 발생시킬 수도 있습니다.
이를 \textbf{re-raise}라고 합니다.

\begin{examplebox}
\begin{lstlisting}
try:
    value = int("abc")
except ValueError:
    print("Logging error...")
    raise
\end{lstlisting}
\end{examplebox}

위 코드의 실행 흐름은 다음과 같습니다.

\begin{enumerate}
  \item \texttt{int("abc")}에서 \texttt{ValueError}가 발생합니다.
  \item \texttt{except ValueError} 블록이 실행됩니다.
  \item 오류를 기록하는 메시지를 출력합니다.
  \item \texttt{raise}를 통해 동일한 예외를 다시 발생시킵니다.
\end{enumerate}

\texttt{raise}를 단독으로 사용하면
현재 처리 중인 예외 객체를 그대로 다시 발생시킵니다.

즉, 예외를 ``완전히 처리하는 것''이 아니라
\textbf{중간 단계에서 일부 작업만 수행한 뒤 상위로 전달하는 것}입니다.

\begin{notebox}
re-raise는 다음과 같은 상황에서 유용합니다.

\begin{itemize}
  \item 오류를 기록(logging)한 뒤 상위 호출자에게 전달할 때
  \item 일부 정리 작업을 수행한 뒤 프로그램을 중단해야 할 때
  \item 라이브러리 내부에서 예외를 숨기지 않고 그대로 전달해야 할 때
\end{itemize}
\end{notebox}

중요한 점은,
\textbf{예외를 무조건 잡아버리는 것보다}
필요한 작업만 수행하고 다시 전달하는 것이
더 안전한 설계라는 것입니다.
무분별하게 예외를 삼켜버리면
문제의 원인이 상위 코드에 전달되지 않아
디버깅이 매우 어려워질 수 있습니다.

% ---------------------------------------------------------
\subsection{사용자 정의 예외 (Custom Exception)}

필요하다면
직접 새로운 예외 클래스를 정의할 수도 있습니다.

기본 문법은 매우 단순합니다.
기존의 \texttt{Exception} 클래스를 상속받으면 됩니다.

\begin{examplebox}
\begin{lstlisting}
class NegativeNumberError(Exception):
    pass

def process(number):
    if number < 0:
        raise NegativeNumberError("Negative value is not allowed.")
    return number * 2

process(-3)
\end{lstlisting}
\end{examplebox}

위 코드에서

\begin{itemize}
  \item \texttt{NegativeNumberError}는 우리가 직접 정의한 예외 클래스
  \item \texttt{Exception}을 상속받아 일반 예외 계층에 포함됨
  \item \texttt{raise}를 통해 해당 예외를 명시적으로 발생시킴
\end{itemize}

입니다.

% ---------------------------------------------------------
\subsubsection{왜 사용자 정의 예외가 필요할까요?}

단순히 \texttt{ValueError}나 \texttt{RuntimeError}를 사용하는 대신
사용자 정의 예외를 만들면 다음과 같은 장점이 있습니다.

\begin{itemize}
  \item 프로그램의 \textbf{의도를 더 명확하게 표현}할 수 있음
  \item 특정 오류 상황을 \textbf{정확하게 구분}할 수 있음
  \item 예외를 \textbf{계층적으로 설계}할 수 있음
\end{itemize}

예를 들어,
``음수는 허용하지 않는다''는 정책은
단순한 값 오류라기보다
\textbf{비즈니스 로직 위반}에 가깝습니다.
이때 별도의 예외 클래스를 정의하면
코드의 의미가 훨씬 분명해집니다.

% ---------------------------------------------------------
\subsection{예외 계층 구조}

파이썬의 예외는 계층 구조를 이루고 있습니다.

\begin{conceptbox}
파이썬 예외의 계층 구조는 다음과 같습니다.
\begin{center}
\texttt{BaseException}
\quad $\rightarrow$ \quad
\texttt{Exception}
\quad $\rightarrow$ \quad
구체적 예외들
\end{center}

예를 들어:

\begin{itemize}
  \item \texttt{ValueError}
  \item \texttt{TypeError}
  \item \texttt{ZeroDivisionError}
\end{itemize}

이들은 모두 \texttt{Exception}의 하위 클래스입니다.
\end{conceptbox}

\begin{notebox}
상위 클래스를 잡으면
하위 예외도 함께 잡힙니다.
따라서 예외 처리 순서는
구체적인 것부터 작성하는 것이 좋습니다.
\end{notebox}

% ---------------------------------------------------------
\subsection{예외 전파 (Propagation)}

예외가 발생했지만 해당 위치에서 처리되지 않으면,
예외는 호출한 함수로 전달됩니다.
이를 \textbf{예외 전파(exception propagation)}라고 합니다.

예외는 함수 호출 구조를 따라
\textbf{콜 스택(call stack)}을 거슬러 올라갑니다.

\begin{examplebox}
\begin{lstlisting}
def inner():
    return 1 / 0

def outer():
    inner()

outer()
\end{lstlisting}
\end{examplebox}

위 코드의 실행 흐름은 다음과 같습니다.

\begin{enumerate}
  \item \texttt{outer()}가 호출됩니다.
  \item \texttt{outer()} 내부에서 \texttt{inner()}가 호출됩니다.
  \item \texttt{inner()}에서 \texttt{1 / 0}이 실행되며
        \texttt{ZeroDivisionError}가 발생합니다.
  \item \texttt{inner()} 안에는 이를 처리하는
        \texttt{try-except} 블록이 없으므로
        예외는 \texttt{outer()}로 전달됩니다.
  \item \texttt{outer()}에서도 처리되지 않으면
        최종적으로 인터프리터까지 전파됩니다.
\end{enumerate}

이때 인터프리터는
\textbf{Traceback}을 출력하고 프로그램을 종료합니다.

% ---------------------------------------------------------
\subsubsection{중간에서 예외를 처리하면?}

전파 과정 중 어느 위치에서든
\texttt{try-except}로 예외를 처리하면
그 시점에서 전파는 멈춥니다.

\begin{examplebox}
\begin{lstlisting}
def inner():
    return 1 / 0

def outer():
    try:
        inner()
    except ZeroDivisionError:
        print("Error handled in outer.")

outer()
\end{lstlisting}
\end{examplebox}

이 경우,
예외는 \texttt{inner()}에서 발생하지만
\texttt{outer()}에서 처리되므로
프로그램은 정상적으로 계속 실행됩니다.

% ---------------------------------------------------------
\begin{notebox}
예외는 ``위로 올라간다''는 표현을 자주 사용합니다.
이는 함수 호출 구조(콜 스택)를 따라
상위 호출자로 전달된다는 의미입니다.
예외를 적절한 위치에서 처리하지 않으면
프로그램은 비정상 종료됩니다.
\end{notebox}

% ---------------------------------------------------------
\subsection{\texttt{assert}}

\texttt{assert} 문은
주어진 조건이 거짓일 경우
자동으로 \texttt{AssertionError}를 발생시킵니다.
즉, 프로그램 내부에서
``이 조건은 반드시 참이어야 한다''는
개발자의 가정을 표현하는 도구입니다.
\texttt{assert} 문의 사용법은 다음과 같습니다.

\begin{examplebox}
\begin{lstlisting}
assert condition, message
\end{lstlisting}
\end{examplebox}

\begin{itemize}
  \item condition이 \texttt{True}이면 아무 일도 일어나지 않음
  \item condition이 \texttt{False}이면 \texttt{AssertionError(message)} 발생
\end{itemize}

\begin{examplebox}
\begin{lstlisting}
def sqrt(x):
    assert x >= 0, "x must be non-negative"
    return x ** 0.5

sqrt(-1)
\end{lstlisting}
\end{examplebox}

위 코드에서
\texttt{x >= 0} 조건이 거짓이면
\texttt{AssertionError}가 발생하며,
두 번째 인자로 전달한 문자열이
오류 메시지로 출력됩니다.

\subsubsection{assert는 언제 사용하는가?}

\texttt{assert}는 다음과 같은 상황에서 사용됩니다.

\begin{itemize}
  \item 내부 불변 조건(invariant) 검증
  \item 개발 중 논리 오류 확인
  \item 디버깅 목적의 가정 검증
\end{itemize}

즉,
\textbf{프로그램 내부 논리의 정확성을 확인하는 용도}입니다.

\begin{notebox}
\texttt{assert}는
사용자 입력 검증용으로 사용하는 것이 적절하지 않습니다.
그 이유는
파이썬을 최적화 모드(\texttt{-O} 옵션)로 실행하면
\texttt{assert} 문이 완전히 제거되기 때문입니다.
따라서,
\textbf{외부 입력 검증이나 실제 오류 처리는}
\texttt{raise}를 사용하는 것이 올바른 방법입니다.
\end{notebox}

% ---------------------------------------------------------
\begin{readernotebox}
예외 심화의 내용을 스스로 점검해 보세요.

\begin{itemize}
  \item \texttt{raise}를 사용하는 상황과 
        단순히 \texttt{return}을 사용하는 상황은 어떻게 다를까요?
  \vspace{0.6cm}

  \item 예외를 한 번 \texttt{except}에서 잡은 뒤
        다시 \texttt{raise}하는 이유는 무엇일까요?
        (로깅, 계층적 설계, 책임 분리 측면에서 생각해 보세요.)
  \vspace{0.6cm}

  \item 사용자 정의 예외를 만드는 것이
        단순히 \texttt{ValueError}를 사용하는 것보다
        더 나은 경우는 언제일까요?
  \vspace{0.6cm}

  \item \texttt{assert}는 왜 사용자 입력 검증에 적절하지 않을까요?
        \texttt{raise}와 비교하여 설명해 보세요.
\end{itemize}

\end{readernotebox}