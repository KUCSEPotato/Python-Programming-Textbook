\chapter{File I/O}

파이썬에서는 로컬 파일을 열고(open),
그 안의 내용을 읽거나(read),
새로운 내용을 파일에 쓰는(write) 작업을 수행할 수 있습니다.

이러한 과정을 \textbf{파일 입출력(File Input / Output, File I/O)}이라고 합니다.

이번 장에서는
파일을 여는 방법,
파일을 읽는 방법,
파일에 데이터를 쓰는 방법,
그리고 작업이 끝난 뒤 파일을 안전하게 닫는 방법까지
체계적으로 정리해 보겠습니다.

\section{파일 다루기}

파일을 다루기 위해서는 먼저 운영체제에 해당 파일을 열어 달라고 요청해야 합니다.
이를 위해 사용하는 함수가 \texttt{open(filename, mode, encoding)}입니다.

\begin{notebox}
운영체제(OS)는
파일을 실제로 저장하고 관리하는 시스템 소프트웨어입니다.
파이썬의 \texttt{open()} 함수는
운영체제에 파일 열기를 요청하고,
그 결과를 파일 객체 형태로 전달받습니다.
대표적인 운영체제는 Windows와 MacOS가 있습니다.
\end{notebox}

\begin{conceptbox}
\texttt{open()} 함수는
파일을 열고(file open),
\textbf{파일 객체(file object)}를 반환합니다.

이 파일 객체를 통해
읽기(read), 쓰기(write), 위치 이동(seek) 등의 작업을 수행합니다.

기본 구조는 다음과 같습니다.

\begin{center}
\texttt{open(filename, mode, encoding=인코딩방식)}
\end{center}
\end{conceptbox}

이때 각 인자의 의미는 다음과 같습니다.

\begin{itemize}
  \item \textbf{filename} : 열고자 하는 파일의 경로 또는 이름
  \item \textbf{mode} : 파일을 어떤 방식으로 열 것인지 지정
  \item \textbf{encoding} : 텍스트 파일의 문자 인코딩 방식
\end{itemize}

\subsection{mode의 기본값}

\texttt{open()} 함수에서
\texttt{filename}을 제외한 인자들은
명시하지 않으면 기본값이 사용됩니다.

특히 \texttt{mode}의 기본값은
\texttt{"r"} (읽기 모드)입니다.

즉,

\begin{examplebox}
\begin{lstlisting}
f = open("example.txt")
\end{lstlisting}
\end{examplebox}

는 다음과 완전히 동일합니다.

\begin{examplebox}
\begin{lstlisting}
f = open("example.txt", "r")
\end{lstlisting}
\end{examplebox}

따라서 파일을 단순히 읽기 위해 열 때는
\texttt{mode}를 생략해도 됩니다.

읽기 모드와 함께 자주 사용하는 모드는 다음과 같습니다.

\begin{itemize}
  \item \texttt{"r"} : 읽기 모드 (파일이 없으면 오류 발생)
  \item \texttt{"w"} : 쓰기 모드 (기존 내용 삭제 후 새로 작성)
  \item \texttt{"a"} : 추가 모드 (파일 끝에 이어서 작성)
  \item \texttt{"b"} : 바이너리 모드 (예: \texttt{"rb"}, \texttt{"wb"})
  \item \texttt{"+"} : 읽기와 쓰기(혹은 추가)를 동시에 허용
\end{itemize}

\begin{notebox}
\texttt{r+}, \texttt{w+}, \texttt{a+} 모드는
하나의 파일 객체로 읽기와 쓰기를 모두 허용합니다.
하지만 다음 두 가지 때문에 초보자가 자주 혼란을 겪습니다.

\begin{itemize}
    \item 파일을 열 때 기존 내용이 유지되는지, 삭제되는지 다릅니다.
    \item 읽기와 쓰기는 \textbf{파일 포인터 위치}의 영향을 받습니다.
\end{itemize}

특히 \texttt{w+} 모드는 파일을 열자마자 기존 내용을 모두 지우므로
실수로 데이터를 날리는 경우가 많습니다.

\textbf{핵심 정리:}
\begin{itemize}
    \item \texttt{r+} : 기존 내용 유지, 읽기/쓰기 가능
    \item \texttt{w+} : 기존 내용 삭제 후 읽기/쓰기 가능
    \item \texttt{a+} : 파일 끝에 추가, 읽기 가능
\end{itemize}

읽기와 쓰기를 함께 사용할 때는
\texttt{seek()}으로 위치를 조정하는 습관이 중요합니다.
\end{notebox}

% ---------------------------------------------------------
\subsection{파일 객체(File Object)}

\texttt{open()}의 반환값은
단순한 문자열이나 숫자가 아니라,
\textbf{파일을 다루기 위한 전용 객체(object)}입니다.
이를 \textbf{파일 객체(file object)}라고 부릅니다.

파일 객체는
\textbf{운영체제가 관리하는 실제 파일(resource)}과
파이썬 코드 사이를 연결하는 \textbf{통로}라고 이해하면 됩니다.
즉, 파일 객체는 파일 자체가 아니라,
\textbf{파일에 접근하기 위한 ``핸들(handle)''}에 가깝습니다.

\begin{conceptbox}
\textbf{파일 객체는 무엇을 기억할까요?}
\begin{itemize}
  \item 어떤 파일을 열었는가? (파일 경로/식별자)
  \item 어떤 모드로 열었는가? (읽기/쓰기/추가/바이너리 등)
  \item 어떤 인코딩을 사용할 것인가? (텍스트 모드일 때)
  \item \textbf{현재 파일 위치(file position)}는 어디인가?
\end{itemize}
\end{conceptbox}

특히 \textbf{현재 파일 위치}는 매우 중요합니다.
파일에서 ``읽기''를 하면 현재 위치부터 읽고,
``쓰기''를 하면 현재 위치에 기록되며,
작업이 끝나면 위치가 앞으로 이동합니다.
이 때문에 파일 작업은 종종
\textbf{커서(cursor)가 움직이는 것}처럼 느껴집니다.

\begin{notebox}
파일 객체는 \textbf{사용 후 반드시 닫아야(close)} 하는 자원을 다룹니다.
닫지 않으면 데이터가 완전히 저장되지 않거나,
운영체제 자원(파일 디스크립터)이 불필요하게 점유될 수 있습니다.
그래서 앞으로 배울 \texttt{with} 문을 사용하면 안전합니다.
\end{notebox}

파일 객체가 제공하는 구체적인 기능(읽기/쓰기/위치 이동 등)은
이후 파일 객체의 메서드를 배우며 하나씩 다루겠습니다.

\subsection{encoding이 왜 중요한가?}

텍스트 파일은 내부적으로
\textbf{바이트(byte)} 단위로 저장됩니다.
이 바이트를 어떤 문자 체계로 해석할지 지정하는 것이
\texttt{encoding}입니다.

\begin{notebox}
대부분의 현대 환경에서는
\texttt{encoding="utf-8"}을 명시하는 것이 안전합니다.
운영체제에 따라 기본 인코딩이 다를 수 있기 때문입니다.
\end{notebox}

특히 한글이나 특수 문자가 포함된 파일을 다룰 때는
인코딩을 명확히 지정하는 습관이 중요합니다.

\subsection{텍스트 모드와 바이너리 모드}

파일은 크게 두 종류로 나눌 수 있습니다.

\begin{itemize}
  \item \textbf{텍스트 파일} : 사람이 읽을 수 있는 문자 데이터
  \item \textbf{바이너리 파일} : 이미지, 실행 파일 등 바이트 데이터
\end{itemize}

텍스트 파일은 인코딩이 필요하지만,
바이너리 파일은 인코딩을 사용하지 않습니다.
따라서 바이너리 파일은 반드시 \texttt{"b"} 모드를 사용해야 합니다.

\subsection{기본 예시: 파일에 쓰기}

파일을 대상으로 작업할 때는
보통 다음과 같은 흐름을 따릅니다.

\begin{examplebox}
\begin{lstlisting}
f = open("example.txt", "w", encoding="utf-8")
f.write("Hello, file!\n")
f.close()
\end{lstlisting}
\end{examplebox}

위 코드의 흐름은 다음과 같습니다.

\begin{enumerate}
  \item \texttt{example.txt} 파일을 \textbf{쓰기 모드(\texttt{"w"})}로 엽니다.
  \item 문자열을 파일에 기록합니다.
  \item 작업이 끝났으므로 파일을 닫습니다.
\end{enumerate}

여기서 \texttt{"w"} 모드는
파일이 이미 존재하면 내용을 \textbf{모두 지우고 새로 작성}합니다.
파일이 존재하지 않으면 새로운 파일을 생성합니다.

또한 문자열 끝의 \texttt{\textbackslash n}은
줄바꿈(newline)을 의미합니다.
파일 역시 텍스트이므로,
화면 출력과 마찬가지로 줄바꿈 문자를 직접 써 주어야 합니다.

\begin{notebox}
파일을 닫지 않으면
기록된 내용이 \textbf{메모리 버퍼(buffer)}에만 남아 있고
실제 디스크에 완전히 저장되지 않을 수 있습니다.

또한 운영체제 자원이 해제되지 않아
예상치 못한 오류가 발생할 수도 있습니다.
따라서 파일 작업이 끝나면 반드시 \texttt{close()}를 호출해야 합니다.
\end{notebox}

% ---------------------------------------------------------
\section{\texttt{with} 문 사용 (권장 방식)}

앞 절에서 보았듯이
파일을 열면 반드시 \texttt{close()}로 닫아야 합니다.
하지만 사람이 직접 닫는 방식을 사용할 경우,
코드가 길어지거나 예외가 발생했을 때
\texttt{close()}가 실행되지 않을 위험이 있습니다.

이 문제를 해결하기 위해
파이썬은 \texttt{with} 문을 제공합니다.

\begin{conceptbox}
\texttt{with} 문은
작업이 끝나면 \textbf{자동으로 정리(clean-up)}를 수행하는 구조입니다.

파일 객체는 \textbf{컨텍스트 관리자(context manager)}로 동작하며,
\texttt{with} 블록을 벗어나는 순간
자동으로 \texttt{close()}가 호출됩니다.
\end{conceptbox}

\subsection{기본 사용 예}

\texttt{with} 구문을 사용한 기본 예제를 살펴봅시다.

\begin{examplebox}
\begin{lstlisting}
with open("example.txt", "r", encoding="utf-8") as f:
    print(f.read())
\end{lstlisting}

출력 결과(예시):
\begin{verbatim}
Hello, file!
\end{verbatim}
\end{examplebox}

위 코드의 흐름은 다음과 같습니다.

\begin{enumerate}
  \item 파일을 엽니다.
  \item \texttt{as f}를 통해 파일 객체를 변수 \texttt{f}에 연결합니다.
  \item 블록 내부에서 파일 작업을 수행합니다.
  \item 블록이 끝나는 즉시 파일이 자동으로 닫힙니다.
\end{enumerate}

그렇다면 왜 \texttt{with} 구문이 중요할까요?
다음과 같은 상황을 생각해 봅시다.

\begin{examplebox}
\begin{lstlisting}
f = open("example.txt", "r")
data = f.read()
raise Exception("error!")
f.close()
\end{lstlisting}
\end{examplebox}

이 경우 예외가 발생하면
\texttt{f.close()}는 실행되지 않습니다.
즉, 파일이 닫히지 않은 상태로 남게 됩니다.
하지만 \texttt{with} 문을 사용하면
예외가 발생하더라도
파일은 안전하게 닫힙니다.

\begin{notebox}
    \textbf{예외(Exception)}란
    프로그램 실행 도중 발생하는 비정상적인 상황을 의미합니다.
    
    예를 들어,
    존재하지 않는 파일을 열려고 하거나,
    0으로 나누기를 시도하는 경우
    예외가 발생합니다.
    
    예외가 발생하면
    이후 코드가 정상적으로 실행되지 않을 수 있습니다.
    예외 처리 방법은
    다음 챕터에서 자세히 다룹니다.
\end{notebox}

\begin{notebox}
실무 코드에서는
\textbf{파일을 열 때는 항상 \texttt{with}를 사용한다}는 것이
거의 규칙에 가깝습니다.

안전성, 가독성, 유지보수 측면에서 모두 유리하기 때문입니다.
\end{notebox}

% ---------------------------------------------------------
\section{파일 객체 메서드}

파일 객체는
파일 내용을 읽거나 쓰고,
현재 위치를 이동하는 등
파일을 조작하기 위한 다양한 메서드를 제공합니다.

% ---------------------------------------------------------
\subsection{\texttt{read()}, \texttt{readline()}, 반복}

텍스트 파일을 읽는 대표적인 방법은 다음 세 가지입니다.

\begin{itemize}
  \item \texttt{read()} :
        파일 전체 내용을 하나의 문자열로 읽기
  \item \texttt{readline()} :
        한 줄씩 읽기 (줄바꿈 문자 포함)
  \item 파일 객체는 반복 가능(iterable) 객체이므로
        \texttt{for}문으로 줄 단위 반복 가능
\end{itemize}

\subsubsection{read() 사용 예}

\begin{examplebox}
\begin{lstlisting}
with open("example.txt", encoding="utf-8") as f:
    content = f.read()
    print(content)
\end{lstlisting}
\end{examplebox}

\begin{notebox}
\texttt{read()}는 파일 전체를 한 번에 읽습니다.
파일이 매우 클 경우
메모리를 많이 사용할 수 있습니다.
\end{notebox}

\subsubsection{readline()}

\texttt{readline()} 메서드는
파일에서 한 줄을 읽어 문자열로 반환합니다.
줄바꿈 문자(\texttt{\textbackslash n})까지 함께 포함되어 반환된다는 점에 유의해야 합니다.

\begin{examplebox}
\begin{lstlisting}
with open("example.txt", encoding="utf-8") as f:
    line1 = f.readline()
    line2 = f.readline()
    print(line1, end="")
    print(line2, end="")
\end{lstlisting}
\end{examplebox}

\begin{notebox}
\texttt{readline()}을 여러 번 호출하면
파일 내부 위치가 한 줄씩 앞으로 이동합니다.
파일 끝에 도달하면
빈 문자열(\texttt{""})을 반환합니다.
\end{notebox}

\texttt{readline()}은
특정 줄까지만 읽고 싶을 때 유용합니다.
예를 들어, 파일의 첫 줄만 확인하는 경우 등에 사용됩니다.

% ---------------------------------------------------------

\subsubsection{for 반복을 이용한 읽기 (권장)}

앞서 살펴본 \texttt{read()} 함수는
파일 전체를 한 번에 메모리로 불러옵니다.
파일이 매우 클 경우
메모리 사용량이 급격히 증가할 수 있습니다.

반면,
파일 객체는 \textbf{반복 가능한(iterable) 객체}이므로
\texttt{for}문을 사용하면
파일을 한 줄씩 자동으로 읽어 처리할 수 있습니다.

\begin{examplebox}
\begin{lstlisting}
with open("example.txt", encoding="utf-8") as f:
    for line in f:
        print(line, end="")
\end{lstlisting}
\end{examplebox}

이 방식은 내부적으로
한 줄씩 읽어오며,
파일 끝에 도달하면 자동으로 반복이 종료됩니다.

\begin{notebox}
텍스트 파일을 반복문으로 읽으면
파일을 한 줄씩 처리하므로
메모리를 효율적으로 사용할 수 있습니다.
대용량 파일 처리에 적합한 방식입니다.
\end{notebox}

정리하면 다음과 같습니다.

\begin{itemize}
  \item 파일 전체를 한 번에 처리할 때 → \texttt{read()}
  \item 특정 줄만 읽을 때 → \texttt{readline()}
  \item 대부분의 일반적인 줄 단위 처리 → \texttt{for line in file} (권장)
\end{itemize}

% ---------------------------------------------------------
\subsection{\texttt{write()}, \texttt{seek()}, \texttt{tell()}}

파일 객체는 데이터를 기록하거나,
파일 내부 위치를 제어하는 기능도 제공합니다.

\begin{itemize}
  \item \texttt{write(data)} :
        파일에 데이터를 기록합니다.
        (텍스트 모드에서는 문자열,
         바이너리 모드에서는 bytes 객체)
  \item \texttt{seek(pos)} :
        파일 내 읽기/쓰기 위치를 지정한 위치로 이동합니다.
  \item \texttt{tell()} :
        현재 파일 위치를 정수 값으로 반환합니다.
\end{itemize}

\subsubsection{파일 위치(file pointer)의 개념}

파일을 열면 운영체제는 파일 내부에 \textbf{현재 읽기/쓰기 위치}를 관리합니다.
이를 흔히 \textbf{파일 포인터(file pointer)}라고 부릅니다.

\begin{conceptbox}
파일 포인터는 ``다음에 읽거나 쓸 위치''를 가리키는 내부 커서(cursor)입니다.
\end{conceptbox}

파일을 처음 열면 파일 포인터는 보통 파일의 시작(위치 0)에 위치합니다.
파일을 읽거나 쓰면 포인터는 자동으로 앞으로 이동합니다.

\subsubsection{\texttt{tell()} 예시}

\begin{examplebox}
\begin{lstlisting}
with open("example.txt", "w", encoding="utf-8") as f:
    f.write("Hello")
    print(f.tell())
\end{lstlisting}

출력 결과(예시):
\begin{verbatim}
5
\end{verbatim}
\end{examplebox}

위 예시에서
\texttt{"Hello"}는 5글자이므로
현재 파일 위치는 5가 됩니다.

\subsubsection{\texttt{seek()} 예시}

\texttt{seek()}를 사용하면
파일 내부 위치를 직접 이동할 수 있습니다.

\begin{examplebox}
\begin{lstlisting}
with open("example.txt", "w+", encoding="utf-8") as f:
    f.write("Hello World")
    f.seek(0)
    print(f.read(5))
\end{lstlisting}

출력 결과(예시):
\begin{verbatim}
Hello
\end{verbatim}
\end{examplebox}

위 코드의 흐름은 다음과 같습니다.

\begin{enumerate}
  \item 파일에 "Hello World"를 기록합니다.
  \item \texttt{seek(0)}으로 파일의 시작 위치로 이동합니다.
  \item 앞에서부터 5글자를 읽습니다.
\end{enumerate}

\begin{notebox}
텍스트 모드에서는 위치가 문자 단위로 계산되지만,
바이너리 모드에서는 바이트 단위로 계산됩니다.
특히 바이너리 파일을 다룰 때
\texttt{seek()}와 \texttt{tell()}의 개념이 매우 중요합니다.
\end{notebox}

% ---------------------------------------------------------
\subsection{바이너리 모드 예시}

텍스트가 아닌
이미지 파일, 실행 파일, 압축 파일 등은
\textbf{바이너리 모드}로 열어야 합니다.

바이너리 모드는
mode에 \texttt{b}를 포함합니다.

\begin{examplebox}
\begin{lstlisting}
with open("binary.bin", "wb+") as f:
    f.write(b"0123456789")
    f.seek(5)
    print(f.read(1))
\end{lstlisting}

출력 결과(예시):
\begin{verbatim}
b'5'
\end{verbatim}
\end{examplebox}

\begin{notebox}
바이너리 모드에서는
문자열(str)이 아닌
\textbf{bytes 객체}를 사용합니다.

따라서
\texttt{b"..."} 형태의 바이트 리터럴을 사용합니다.
\end{notebox}