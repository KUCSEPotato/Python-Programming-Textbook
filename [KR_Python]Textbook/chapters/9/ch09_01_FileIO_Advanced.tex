% ---------------------------------------------------------
\section{JSON으로 구조적 데이터 저장}

단순 문자열이 아니라
리스트나 딕셔너리 같은 구조적 데이터를 저장하고 싶다면
JSON 형식을 사용할 수 있습니다.

\begin{conceptbox}
JSON(JavaScript Object Notation)은
구조적인 데이터를 텍스트 형태로 표현하는 표준 형식입니다.
파이썬의 \texttt{dict}, \texttt{list}, \texttt{int}, \texttt{float}, \texttt{str}
등과 자연스럽게 대응됩니다.
\end{conceptbox}

JSON은 사람이 읽을 수 있는 텍스트 파일이기 때문에
디버깅, 데이터 교환, 웹 API 통신 등에 널리 사용됩니다.

% ---------------------------------------------------------
\subsection{저장 (\texttt{json.dump})}

파이썬에서 JSON 형식의 데이터를 다루기 위해서는
표준 라이브러리인 \texttt{json} 모듈을 import해야 합니다.

\begin{conceptbox}
\begin{itemize}
  \item \texttt{json.dump(obj, file)}  
        파이썬 객체를 JSON 형식으로 \textbf{파일에 저장}

  \item \texttt{json.load(file)}  
        JSON 파일을 읽어 \textbf{파이썬 객체로 변환}
\end{itemize}
\end{conceptbox}

JSON은 텍스트 기반 형식이므로,
파일 안에는 사람이 읽을 수 있는 문자열 형태로 저장됩니다.

파이썬 자료형과 JSON의 기본 대응 관계는 다음과 같습니다.

\begin{itemize}
  \item \texttt{dict} → JSON 객체(object)
  \item \texttt{list}, \texttt{tuple} → JSON 배열(array)
  \item \texttt{str} → 문자열(string)
  \item \texttt{int}, \texttt{float} → 숫자(number)
  \item \texttt{True/False} → true/false
  \item \texttt{None} → null
\end{itemize}

\begin{examplebox}
\begin{lstlisting}
import json

data = {"name": "Alice", "age": 20}

with open("data.json", "w", encoding="utf-8") as f:
    json.dump(data, f, indent=2, ensure_ascii=False)
\end{lstlisting}
\end{examplebox}

위 코드의 흐름은 다음과 같습니다.

\begin{enumerate}
  \item 파이썬 딕셔너리 객체를 준비합니다.
  \item 파일을 쓰기 모드로 엽니다.
  \item \texttt{json.dump()}가 객체를 JSON 문자열로 변환하여 파일에 기록합니다.
\end{enumerate}

\begin{notebox}
\texttt{indent=2} 옵션은 JSON을 보기 좋게 들여쓰기 합니다.  
\texttt{ensure}\verb|_|\texttt{ascii=False} 옵션은 한글과 같은 비 ASCII 문자를
이스케이프하지 않고 그대로 저장합니다.
실무에서는 가독성을 위해 \texttt{indent} 옵션을 자주 사용합니다.
\end{notebox}

% ---------------------------------------------------------
\subsection{불러오기 (\texttt{json.load})}

이제 저장된 JSON 파일을 다시 읽어보겠습니다.

\begin{examplebox}
\begin{lstlisting}
import json

with open("data.json", encoding="utf-8") as f:
    loaded = json.load(f)

print(loaded)
\end{lstlisting}

출력 결과(예시):
\begin{verbatim}
{'name': 'Alice', 'age': 20}
\end{verbatim}
\end{examplebox}

\texttt{json.load()}는 다음 과정을 수행합니다.

\begin{enumerate}
  \item 파일의 JSON 문자열을 읽습니다.
  \item 이를 파싱(parse)하여
  \item 대응되는 파이썬 객체(dict, list 등)로 변환합니다.
\end{enumerate}

즉,

\begin{center}
파이썬 객체 → JSON 텍스트 → 다시 파이썬 객체
\end{center}

의 변환이 자동으로 처리됩니다.

\begin{notebox}
JSON은 서로 다른 언어(Python, JavaScript, Java 등) 간
데이터를 교환할 때 매우 널리 사용됩니다.
따라서 JSON을 이해하는 것은 단순 파일 저장 이상의 의미를 가집니다.
\end{notebox}

% ---------------------------------------------------------
\subsection{JSON의 한계}

JSON은 매우 편리하지만,
모든 파이썬 객체를 저장할 수 있는 것은 아닙니다.

예를 들어 다음과 같은 객체는
직접 저장할 수 없습니다.

\begin{itemize}
  \item 사용자 정의 클래스 객체
  \item 함수
  \item set 자료형
\end{itemize}

이러한 객체를 저장하려면
다른 직렬화(serialization) 방법이 필요합니다.

% ---------------------------------------------------------
\section{pickle: 파이썬 객체 그대로 저장하기}

\texttt{pickle} 또한 \texttt{json}처럼
파이썬 객체를 파일로 저장하고 다시 불러오는 데 사용됩니다.
다만, \texttt{json}이 텍스트 기반의 표준 형식이라면,
\texttt{pickle}은 파이썬 전용의 이진(binary) 직렬화 형식이라는 차이가 있습니다.

\begin{conceptbox}
\texttt{pickle}은
파이썬 객체를 그대로 바이트 형태로 변환하여 저장하는 모듈입니다.
이를 \textbf{직렬화(serialization)}라고 합니다.
\end{conceptbox}

\subsection{저장 (\texttt{pickle.dump})}

\texttt{pickle}을 사용하기 위해서는
\texttt{json}과 마찬가지로
먼저 해당 모듈을 임포트해야 합니다.

\begin{examplebox}
\begin{lstlisting}
import pickle

data = {"name": "Alice", "scores": [90, 85, 88]}

with open("data.pkl", "wb") as f:
    pickle.dump(data, f)
\end{lstlisting}
\end{examplebox}

\subsection{불러오기 (\texttt{pickle.load})}

\begin{examplebox}
\begin{lstlisting}
import pickle

with open("data.pkl", "rb") as f:
    loaded = pickle.load(f)

print(loaded)
\end{lstlisting}

출력 결과(예시):
\begin{verbatim}
{'name': 'Alice', 'scores': [90, 85, 88]}
\end{verbatim}
\end{examplebox}

\begin{notebox}
\texttt{pickle}은 파이썬 전용 형식입니다.
다른 언어와 데이터 교환을 할 때는 JSON이 적합합니다.
\end{notebox}

\begin{notebox}
\textbf{매우 중요한 보안 경고}

\texttt{pickle.load()}는 단순히 데이터를 읽는 것이 아니라,
파일 안에 저장된 객체를 \textbf{그대로 복원(reconstruct)}합니다.
이 과정에서
임의의 파이썬 코드가 실행될 수 있습니다.
따라서
\textbf{출처를 신뢰할 수 없는 pickle 파일을 절대 로드하면 안 됩니다.}
악성 코드가 포함된 pickle 파일을 로드하는 순간,
프로그램이 의도하지 않은 코드를 실행하게 되며,
이는 시스템 손상이나 정보 유출로 이어질 수 있습니다.

\textbf{pickle은 오직 신뢰할 수 있는 내부 데이터에만 사용하십시오.}
\end{notebox}

% ---------------------------------------------------------
\section{파일 경로 다루기: \texttt{os}와 \texttt{pathlib}}

파일을 다룰 때는
단순히 파일을 여는 것뿐 아니라
\textbf{파일 경로(path)}를 정확히 다루는 것이 매우 중요합니다.
경로는 운영체제에 따라 표현 방식이 다릅니다.

\begin{itemize}
  \item Windows: \texttt{C:\textbackslash Users\textbackslash ...}
  \item macOS / Linux: \texttt{/home/...}
\end{itemize}

따라서 문자열을 단순히 이어 붙이는 방식으로
경로를 처리하면
운영체제에 따라 오류가 발생할 수 있습니다.

이 문제를 해결하기 위해
파이썬은 경로 처리를 위한 도구를 제공합니다.
대표적으로 \texttt{os.path}와 \texttt{pathlib}이 있습니다.

% ---------------------------------------------------------
\subsection{\texttt{os.path}}

\texttt{os.path}는
전통적으로 사용되어 온 경로 처리 모듈입니다.

\begin{examplebox}
\begin{lstlisting}
import os

print(os.path.exists("data.json"))
print(os.path.abspath("data.json"))
print(os.path.join("folder", "data.json"))
\end{lstlisting}
\end{examplebox}

예시에 사용된 함수들의 의미는 다음과 같습니다.

\begin{itemize}
  \item \texttt{exists(path)} :
        파일 또는 디렉터리 존재 여부 확인

  \item \texttt{abspath(path)} :
        절대 경로(absolute path) 반환

  \item \texttt{join(path1, path2)} :
        운영체제에 맞는 구분자로 경로를 결합
\end{itemize}

\begin{notebox}
경로를 문자열로 직접 연결하지 말고
\texttt{os.path.join()}을 사용하는 습관이 중요합니다.
운영체제별 경로 구분자 차이를 자동으로 처리해 줍니다.
\end{notebox}

% ---------------------------------------------------------
\subsection{\texttt{pathlib} (권장 방식)}

최근 파이썬에서는
전통적인 \texttt{os.path} 방식보다
\textbf{\texttt{pathlib}} 사용이 권장됩니다.

\begin{conceptbox}
\texttt{pathlib}은
파일 경로를 단순한 ``문자열(string)''이 아니라
\textbf{경로 객체(Path object)}로 다루는
객체 지향 방식의 표준 라이브러리입니다.
\end{conceptbox}

기존에는 파일 경로를 문자열로 다루었기 때문에,
경로 결합이나 확인을 위해
\texttt{os.path.join()}, \texttt{os.path.exists()}와 같은
별도의 함수를 호출해야 했습니다.

반면 \texttt{pathlib}에서는
경로 자체가 하나의 객체이므로,
경로와 관련된 기능을
\textbf{메서드 형태로 자연스럽게 호출}할 수 있습니다.

\subsubsection{Path 객체 생성}

\begin{examplebox}
\begin{lstlisting}
from pathlib import Path

path = Path("data.json")

print(path.exists())
print(path.resolve())
print(path.is_file())
print(path.is_dir())
\end{lstlisting}
\end{examplebox}

\texttt{path}는 단순 문자열이 아니라 파일 시스템 경로를 표현하는 객체입니다.
이 객체를 통해 다음과 같은 작업을 수행할 수 있습니다.

\begin{itemize}
  \item \texttt{exists()} :
        경로가 실제로 존재하는지 확인

  \item \texttt{resolve()} :
        상대 경로를 절대 경로로 변환

  \item \texttt{is\_file()} :
        해당 경로가 파일인지 확인

  \item \texttt{is\_dir()} :
        해당 경로가 디렉터리인지 확인
\end{itemize}

\begin{notebox}
\texttt{resolve()}는
상대 경로(relative path)를
현재 작업 디렉터리를 기준으로
절대 경로(absolute path)로 변환합니다.
경로 문제를 디버깅할 때 매우 유용합니다.
\end{notebox}

\begin{notebox}
\textbf{상대 경로(relative path)와 절대 경로(absolute path)}

파일 경로에는 두 가지 방식이 있습니다.

\begin{itemize}
  \item \textbf{절대 경로(absolute path)} :
        파일 시스템의 최상위(root)부터 시작하는 전체 경로

  \item \textbf{상대 경로(relative path)} :
        현재 작업 디렉터리(current working directory)를 기준으로 한 경로
\end{itemize}

예를 들어,

\begin{itemize}
  \item 절대 경로 예시 (Windows) :
        \texttt{C:\textbackslash Users\textbackslash student\textbackslash project\textbackslash data.json}

  \item 절대 경로 예시 (macOS/Linux) :
        \texttt{/Users/student/project/data.json}

  \item 상대 경로 예시 :
        \texttt{data.json}
        \quad 또는 \quad
        \texttt{folder/data.json}
\end{itemize}

상대 경로는
\textbf{현재 프로그램이 실행되는 위치}에 따라
해석 결과가 달라질 수 있습니다.

따라서 경로 오류가 발생할 경우,
다음 코드를 통해 현재 작업 디렉터리를 확인해 보는 것이 좋습니다.

\begin{verbatim}
import os
print(os.getcwd())
\end{verbatim}

또는 \texttt{pathlib}에서는

\begin{verbatim}
from pathlib import Path
print(Path().resolve())
\end{verbatim}

을 사용하면 현재 기준 위치를 확인할 수 있습니다.
\end{notebox}

% ---------------------------------------------------------
\subsection{경로 결합}

\texttt{pathlib}에서는
경로 결합을 \texttt{/} 연산자로 수행할 수 있습니다.

\begin{examplebox}
\begin{lstlisting}
from pathlib import Path

base = Path("folder")
file_path = base / "data.json"

print(file_path)
\end{lstlisting}
\end{examplebox}

위 코드의 동작 과정을 단계별로 살펴보겠습니다.

\begin{enumerate}
  \item \texttt{Path("folder")} :
        \texttt{"folder"}라는 이름의 경로를 나타내는
        \texttt{Path} 객체를 생성합니다.
        이 객체는 단순 문자열이 아니라
        경로 전용 기능을 가진 객체입니다.

  \item \texttt{base / "data.json"} :
        \texttt{/} 연산자는 실제 나눗셈이 아니라,
        \textbf{경로를 결합(join)}하는 연산자입니다.
        즉, \texttt{"folder/data.json"} 경로를 생성합니다.

  \item \texttt{print(file\_path)} :
        생성된 경로 객체를 문자열 형태로 출력합니다.
\end{enumerate}

이 방식은
운영체제에 맞는 경로 구분자
(\texttt{/} 또는 \texttt{\textbackslash})를
자동으로 적용합니다.

% ---------------------------------------------------------
\subsection{파일 열기와 함께 사용하기}

\texttt{pathlib} 객체는
\texttt{open()} 메서드를 직접 제공합니다.

\begin{examplebox}
\begin{lstlisting}
from pathlib import Path

path = Path("data.json")

with path.open("r", encoding="utf-8") as f:
    print(f.read())
\end{lstlisting}
\end{examplebox}

이 방식은 경로 객체 생성, 파일 열기, 읽기와 쓰기 과정을 자연스럽게 연결합니다.
따라서, 문자열 기반 경로보다 \textbf{의도가 명확하고 실수 가능성이 적습니다.}

\begin{notebox}
\textbf{\texttt{open()}과 \texttt{Path.open()}의 차이}

\begin{itemize}
  \item \texttt{open("file.txt", ...)} :
        파일 경로를 문자열로 전달하는 전통적인 방식

  \item \texttt{Path("file.txt").open(...)} :
        \texttt{Path} 객체의 메서드를 이용하는 방식
\end{itemize}

두 방식은 \textbf{기능적으로 동일}합니다.
즉, 내부적으로는 같은 파일 열기 동작을 수행합니다.

차이는 \textbf{경로를 다루는 방식}에 있습니다.

\begin{itemize}
  \item \texttt{open()} :
        경로를 문자열로 직접 관리

  \item \texttt{pathlib} :
        경로를 객체로 관리하고,
        경로 관련 기능과 파일 열기를 자연스럽게 연결
\end{itemize}

따라서 현대적인 코드에서는

\begin{center}
\texttt{Path 객체 생성 → 경로 조작 → path.open()}
\end{center}

과 같은 흐름이 더 일관되고 가독성이 좋습니다.
\end{notebox}

% ---------------------------------------------------------
\subsection{디렉터리 생성과 탐색}

\texttt{pathlib}은 파일뿐 아니라
\textbf{디렉터리(directory)}를 다루는 작업에도 매우 유용합니다.
파일 시스템을 다룬다는 것은 단순히 파일을 읽고 쓰는 것뿐 아니라,

\begin{itemize}
  \item 폴더를 생성하고
  \item 특정 위치의 파일 목록을 확인하고
  \item 조건에 맞는 파일만 검색하는 작업
\end{itemize}

을 포함합니다.

\begin{examplebox}
\begin{lstlisting}
from pathlib import Path

folder = Path("new_folder")
folder.mkdir(exist_ok=True)

for item in Path(".").iterdir():
    print(item)
\end{lstlisting}
\end{examplebox}

위 코드의 의미는 다음과 같습니다.

\begin{itemize}
  \item \texttt{Path("new\_folder")} :
        해당 이름의 경로 객체 생성

  \item \texttt{mkdir(exist\_ok=True)} :
        디렉터리 생성  
        이미 존재하면 오류를 발생시키지 않음

  \item \texttt{Path(".")} :
        현재 디렉터리를 의미

  \item \texttt{iterdir()} :
        현재 디렉터리 내부의 모든 항목을
        \textbf{Path 객체 형태로 하나씩 반환}
\end{itemize}

\begin{notebox}
\texttt{iterdir()}는 문자열을 반환하지 않고
\textbf{Path 객체}를 반환합니다.
따라서 반환된 객체에 대해
\texttt{is\_file()}, \texttt{is\_dir()} 등의 메서드를
바로 사용할 수 있습니다.
\end{notebox}

% ---------------------------------------------------------
\subsection{패턴 기반 파일 검색: \texttt{glob()}}

특정 확장자를 가진 파일만 찾고 싶을 때는
\texttt{glob()} 메서드를 사용합니다.

\begin{examplebox}
\begin{lstlisting}
from pathlib import Path

for txt_file in Path(".").glob("*.txt"):
    print(txt_file)
\end{lstlisting}
\end{examplebox}

\texttt{"*.txt"}는
\textbf{와일드카드 패턴(wildcard pattern)}입니다.

\begin{itemize}
  \item \texttt{*} : 모든 문자열을 의미
  \item \texttt{*.txt} : 확장자가 \texttt{.txt}인 모든 파일
\end{itemize}

\texttt{glob()} 역시
\textbf{Path 객체들을 반복적으로 반환}합니다.

하위 디렉터리까지 포함하여 검색하고 싶다면
\texttt{rglob()}을 사용할 수 있습니다.

\begin{examplebox}
\begin{lstlisting}
for txt_file in Path(".").rglob("*.txt"):
    print(txt_file)
\end{lstlisting}
\end{examplebox}

\begin{notebox}
\texttt{glob()}은 현재 디렉터리만 검색하고,
\texttt{rglob()}은 하위 디렉터리까지 재귀적으로 검색합니다.
\end{notebox}

% ---------------------------------------------------------
\begin{notebox}
현대적인 파이썬 코드에서는
\textbf{\texttt{pathlib} 사용을 강력히 권장합니다.}

이유는 다음과 같습니다.

\begin{itemize}
  \item 경로를 문자열이 아닌 객체로 다루므로 오류 가능성이 줄어듦
  \item 운영체제별 경로 구분자(\texttt{/}, \texttt{\textbackslash})를 자동 처리
  \item 가독성이 높고 코드가 직관적임
\end{itemize}

특히 프로젝트 규모가 커질수록
\texttt{pathlib}의 장점은 더욱 커집니다.
\end{notebox}

% ---------------------------------------------------------
\begin{exercisebox}
\textbf{Exercise 1. 기본 파일 쓰기}

현재 디렉터리에 \texttt{numbers.txt} 파일을 생성하고,
1부터 10까지의 숫자를 한 줄에 하나씩 저장하는 코드를 작성해 보세요.
(\texttt{with} 문을 반드시 사용할 것)
\end{exercisebox}

% ---------------------------------------------------------
\begin{exercisebox}
\textbf{Exercise 2. 파일 읽기와 합 계산}

\texttt{numbers.txt} 파일을 읽어
저장된 숫자들의 총합을 계산하는 프로그램을 작성해 보세요.

\begin{itemize}
  \item 각 줄을 읽어 정수로 변환해야 합니다.
  \item 반복문을 활용하세요.
\end{itemize}
\end{exercisebox}

% ---------------------------------------------------------
\begin{exercisebox}
\textbf{Exercise 3. JSON 저장과 복원}

다음과 같은 딕셔너리를 JSON 파일로 저장한 뒤,
다시 불러와 출력해 보세요.

\begin{verbatim}
{"title": "Python", "year": 2026, "topics": ["I/O", "JSON", "pathlib"]}
\end{verbatim}

\begin{itemize}
  \item 저장 시 \texttt{indent=2} 옵션을 사용하세요.
  \item 불러온 객체의 타입을 \texttt{type()}으로 확인해 보세요.
\end{itemize}
\end{exercisebox}

% ---------------------------------------------------------
\begin{exercisebox}
\textbf{Exercise 4. pathlib 활용하기}

현재 디렉터리에서 확장자가 \texttt{.py}인 파일만 찾아
파일 이름을 출력하는 코드를 작성해 보세요.

\begin{itemize}
  \item \texttt{Path().glob()}을 사용할 것
  \item 하위 디렉터리까지 포함하도록 수정해 보세요.
\end{itemize}
\end{exercisebox}

% ---------------------------------------------------------
\begin{readernotebox}
File I/O 단원의 핵심을 스스로 점검해 보세요.

\begin{itemize}
  \item 왜 실무에서는 \texttt{open()}보다 \texttt{with open()} 방식이 권장될까요?
  \vspace{0.6cm}

  \item 텍스트 모드(\texttt{"r"}, \texttt{"w"})와
        바이너리 모드(\texttt{"rb"}, \texttt{"wb"})의 차이는 무엇인가요?
  \vspace{0.6cm}

  \item \texttt{json}과 \texttt{pickle}은 모두 객체를 저장할 수 있습니다.
        그렇다면 두 방식의 가장 중요한 차이점은 무엇인가요?
  \vspace{0.6cm}

  \item 상대 경로와 절대 경로는 언제 각각 사용하는 것이 적절할까요?
  \vspace{0.6cm}

  \item \texttt{os.path} 대신 \texttt{pathlib} 사용이 권장되는 이유는 무엇인가요?
\end{itemize}
\end{readernotebox}