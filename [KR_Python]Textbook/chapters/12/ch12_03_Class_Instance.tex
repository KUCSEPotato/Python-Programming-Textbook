% 0216 수정중
% ---------------------------------------------------------
\section{인스턴스 객체, 메서드 객체, 그리고 호출 규약}

% ---------------------------------------------------------
\subsection{인스턴스가 이해하는 핵심 연산: 어트리뷰트 참조}

인스턴스는 \texttt{x.name} 형태로 어트리뷰트를 참조할 수 있습니다.
이때 어트리뷰트는 크게 두 종류로 나뉩니다.

\begin{itemize}
  \item 데이터 어트리뷰트(인스턴스 변수)
  \item 메서드(인스턴스에 속한 함수처럼 보이는 것)
\end{itemize}

\begin{examplebox}
\begin{lstlisting}
class MyClass:
    def __init__(self):
        self.data = []

    def add(self, x):
        self.data.append(x)

x = MyClass()
x.add(10)
x.add(20)
print(x.data)
\end{lstlisting}

출력 결과(예시):
\begin{verbatim}
[10, 20]
\end{verbatim}
\end{examplebox}

% ---------------------------------------------------------
\subsection{메서드 객체: 함수와 인스턴스가 결합된다}

클래스에 정의된 함수는
인스턴스를 통해 접근할 때
``인스턴스와 결합된 형태''로 동작합니다.

\begin{conceptbox}
\texttt{x.f()}는 대체로 \texttt{C.f(x)}와 같은 의미입니다.
즉, \texttt{self}에 인스턴스가 자동으로 전달됩니다.
\end{conceptbox}

\begin{examplebox}
\begin{lstlisting}
class MyClass:
    def f(self):
        return "hello world"

x = MyClass()

print(MyClass.f(x))
print(x.f())
\end{lstlisting}

출력 결과(예시):
\begin{verbatim}
hello world
hello world
\end{verbatim}
\end{examplebox}

% ---------------------------------------------------------
\subsection{메서드는 저장해 두었다가 호출할 수도 있다}

\begin{examplebox}
\begin{lstlisting}
class MyClass:
    def f(self):
        return "hello world"

x = MyClass()
xf = x.f
print(xf())
print(xf())
\end{lstlisting}

출력 결과(예시):
\begin{verbatim}
hello world
hello world
\end{verbatim}
\end{examplebox}

% ---------------------------------------------------------
\section{클래스 변수와 인스턴스 변수의 조회 규칙}

인스턴스 \texttt{obj}에서 \texttt{obj.attr}을 조회할 때,
일반적으로 다음 흐름이 성립합니다(단순화).

\begin{itemize}
  \item 먼저 인스턴스 자신의 어트리뷰트에서 \texttt{attr}을 찾는다
  \item 없으면 클래스의 어트리뷰트에서 찾는다
  \item 상속이 있으면 베이스 클래스로 올라가며 찾는다
\end{itemize}

% ---------------------------------------------------------
\subsection{인스턴스가 우선한다}

\begin{examplebox}
\begin{lstlisting}
class Warehouse:
    purpose = "storage"
    region = "west"

w1 = Warehouse()
print(w1.purpose, w1.region)

w2 = Warehouse()
w2.region = "east"
print(w2.purpose, w2.region)
\end{lstlisting}

출력 결과(예시):
\begin{verbatim}
storage west
storage east
\end{verbatim}
\end{examplebox}

\begin{notebox}
\texttt{w2.region = "east"}는 클래스 변수를 바꾼 것이 아니라,
\texttt{w2} 인스턴스에 \texttt{region}이라는 새 어트리뷰트를 만든 것입니다.
따라서 \texttt{w1.region}은 계속 \texttt{"west"}입니다.
\end{notebox}