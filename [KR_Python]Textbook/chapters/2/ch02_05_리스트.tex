\section{리스트(List)}

여러 개의 값을 하나의 변수에 담아
함께 관리해야 하는 상황이 자주 발생합니다.
지금까지 살펴본 자료형들은
하나의 변수에 하나의 값만을 저장했지만,
리스트는 여러 개의 값을
하나의 자료형으로 묶어 다룰 수 있습니다.

\begin{conceptbox}
리스트는 여러 개의 값을
하나의 변수에 담아 사용하는 자료형입니다.
리스트는 대괄호(\texttt{[]})를 사용하여 생성하며,
각 값은 쉼표로 구분합니다.

리스트 내부에 저장된 각 값을
\textbf{요소(element)}라고 하며,
요소에 접근할 때는
\textbf{인덱스(index)}를 사용합니다.
Python에서 인덱스는 \textbf{0부터 시작}합니다.
\end{conceptbox}

\begin{notebox}
리스트는 \textbf{순서(order)}가 있는 자료형입니다.
즉, 리스트에 저장된 요소들은
입력된 순서를 유지하며 저장됩니다.
이 때문에 각 요소에
인덱스를 사용하여 접근할 수 있습니다.
\end{notebox}

리스트의 기본적인 형태와 사용 예시는 다음과 같습니다.

\begin{examplebox}
\begin{lstlisting}
# define list
list_a = [123, 45, 6, "String", True]

print(list_a[0])
print(list_a[1:3])

# change an element
list_a[4] = "Python"
print(list_a)
\end{lstlisting}

출력 결과:
\begin{verbatim}
123
[45, 6]
[123, 45, 6, "String", "Python"]
\end{verbatim}
\end{examplebox}

위 예시에서 주목할 점은,
하나의 리스트에
서로 다른 자료형의 값들을
함께 저장할 수 있다는 점입니다.
Python의 리스트는
각 요소의 자료형이 서로 달라도
문제없이 사용할 수 있습니다.
이러한 특성 덕분에
리스트는 다양한 데이터를
유연하게 관리할 수 있는 자료형입니다.
위와 같은 기본적인 사용법 외에도,
리스트는 다양한 방식으로 활용할 수 있습니다.

\newpage
\subsection{리스트 활용하기}

\subsubsection{음수 인덱스를 이용한 요소 접근}

문자열에서 음수 인덱스를 사용해
뒤에서부터 문자를 선택했던 것처럼,
리스트에서도 음수 인덱스를 사용할 수 있습니다.
음수 인덱스를 사용하면
리스트의 마지막 요소부터
거꾸로 접근할 수 있습니다.

\begin{examplebox}
\begin{lstlisting}
numbers = [1, 2, 3, 4, 5]

print(numbers[-1])
print(numbers[-2])
print(numbers[-3])
\end{lstlisting}

출력 결과:
\begin{verbatim}
5
4
3
\end{verbatim}
\end{examplebox}

\subsubsection{슬라이싱}

리스트에서는
\textbf{슬라이싱(slicing)}을 사용하여
리스트의 일부 요소들만을 선택할 수 있습니다.
리스트 슬라이싱의 사용법은
앞에서 살펴본
\textbf{문자열 슬라이싱과 매우 유사}합니다.

실제로 앞선 기초 활용 예시에서도
\texttt{리스트[1:3]}과 같은 형태로
리스트의 일부를 선택하는 예제를 이미 살펴보았습니다.
이처럼 리스트에서도
문자열과 동일한 규칙으로
슬라이싱을 사용할 수 있습니다.

\begin{conceptbox}
리스트 슬라이싱의 기본 형태는
\texttt{리스트[시작:끝]}입니다.
이때 시작 인덱스는 포함되지만,
끝 인덱스는 포함되지 않습니다.
\end{conceptbox}

\begin{examplebox}
\begin{lstlisting}
numbers = [10, 20, 30, 40, 50]
print(numbers[1:4])
\end{lstlisting}

출력 결과:
\begin{verbatim}
[20, 30, 40]
\end{verbatim}
\end{examplebox}

슬라이싱에서
시작 인덱스나 종료 인덱스는
생략할 수 있습니다.
시작 인덱스를 생략하면
리스트의 처음부터,
종료 인덱스를 생략하면
리스트의 끝까지 선택됩니다.

\begin{examplebox}
\begin{lstlisting}
print(numbers[:3])
print(numbers[2:])
print(numbers[:])
\end{lstlisting}

출력 결과:
\begin{verbatim}
[10, 20, 30]
[30, 40, 50]
[10, 20, 30, 40, 50]
\end{verbatim}
\end{examplebox}

리스트 슬라이싱에서는
음수 인덱스도 사용할 수 있으며,
이를 통해 리스트의 뒤쪽 요소들을
선택할 수 있습니다.

\begin{examplebox}
\begin{lstlisting}
print(numbers[-3:])
print(numbers[:-1])
\end{lstlisting}

출력 결과:
\begin{verbatim}
[30, 40, 50]
[10, 20, 30, 40]
\end{verbatim}
\end{examplebox}

\begin{notebox}
리스트 슬라이싱의 결과는
항상 \textbf{새로운 리스트}입니다.
즉, 슬라이싱을 사용해도
원본 리스트는 변경되지 않습니다.
이 점 역시 문자열 슬라이싱과 동일합니다.
\end{notebox}

\subsubsection{이중 인덱싱}

리스트의 요소가 문자열인 경우,
리스트 인덱싱과 문자열 인덱싱을
연속으로 사용할 수 있습니다.

\begin{examplebox}
\begin{lstlisting}
words = ["Hello", "World", "Python"]
print(words[1][0])
\end{lstlisting}

출력 결과:
\begin{verbatim}
W
\end{verbatim}
\end{examplebox}

위 예시는
리스트에서 문자열 \texttt{"World"}를 먼저 선택한 뒤,
해당 문자열의 첫 번째 문자를 다시 선택한 결과입니다.

\subsubsection{리스트 안에 리스트 사용하기}

리스트의 요소로
다른 리스트를 저장할 수도 있습니다.
이러한 구조를
\textbf{중첩 리스트(nested list)}라고 합니다.

\begin{examplebox}
\begin{lstlisting}
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

print(matrix[1])
print(matrix[2][1])
\end{lstlisting}

출력 결과:
\begin{verbatim}
[4, 5, 6]
8
\end{verbatim}
\end{examplebox}

이와 같이 중첩 리스트를 사용하면
행과 열 구조의 데이터를
자연스럽게 표현할 수 있습니다.

\begin{notebox}
리스트의 인덱스 범위를 벗어난 위치에
접근하려 하면
\texttt{IndexError} 예외가 발생합니다.
이는 존재하지 않는 요소를
참조하려고 했기 때문입니다.
\end{notebox}

\begin{examplebox}
\begin{lstlisting}
values = [1, 2, 3]
print(values[3])
\end{lstlisting}

출력 결과:
\begin{verbatim}
IndexError: list index out of range
\end{verbatim}
\end{examplebox}

\subsubsection{뮤터블(mutable)한 리스트 자료형}

\begin{conceptbox}
Python에서 \textbf{뮤터블(mutable)한 자료형}이란,
\textbf{객체 자체의 값을 변경할 수 있는 자료형}을 의미합니다.
즉, 새로운 객체를 만들지 않고도
기존 객체의 내부 값을 수정할 수 있습니다.
\end{conceptbox}

리스트는 대표적인 뮤터블 자료형입니다.
리스트의 요소는
인덱스를 사용하여
직접 변경할 수 있습니다.

\begin{examplebox}
\begin{lstlisting}
numbers = [1, 2, 3]
numbers[0] = 10
print(numbers)
\end{lstlisting}

출력 결과:
\begin{verbatim}
[10, 2, 3]
\end{verbatim}
\end{examplebox}

위 예시에서 볼 수 있듯이,
리스트는 기존 객체를 유지한 채
내부 요소만 변경됩니다.

\begin{notebox}
문자열(\texttt{str})은
뮤터블하지 않은(immutable) 자료형입니다.
문자열의 일부를 직접 변경할 수 없으며,
항상 새로운 문자열이 생성됩니다.
이 차이는 리스트와 문자열을 구분하는
중요한 기준 중 하나입니다.
\end{notebox}

\begin{exercisebox}
다음 코드가 실행된 후,
각 변수의 값이 어떻게 되는지 예측해 보세요.
코드를 직접 실행하기 전에
반드시 결과를 먼저 생각해 보시기 바랍니다.

\begin{enumerate}
    \item 다음 코드의 실행 결과를 작성하세요.
    \begin{verbatim}
a = [1, 2, 3, 4]
b = a[1:3]
b[0] = 100
print(a)
print(b)
    \end{verbatim}

    \vspace{1.2cm}

    \item 다음 코드의 실행 결과를 작성하세요.
    \begin{verbatim}
c = [10, 20, 30]
d = c
d[1] = 99
print(c)
print(d)
    \end{verbatim}

    \vspace{1.2cm}

    \item 위 두 코드의 결과가 서로 다른 이유를
    ``뮤터블한 자료형''과
    ``슬라이싱''의 개념을 사용하여 설명해 보세요.
\end{enumerate}
\end{exercisebox}

\begin{readernotebox}
자유롭게 지금까지의 내용을 정리해보세요.

\end{readernotebox}

\subsection{리스트 자료형 메서드}

앞 절에서는 리스트의 인덱싱과 슬라이싱을 통해
요소에 접근하는 방법을 살펴보았습니다.
이번 절에서는 리스트 객체가 제공하는
\textbf{리스트 메서드(method)}를 학습합니다.

리스트 메서드를 사용하면
요소를 추가하거나 삭제하고,
원하는 위치에 값을 삽입하거나,
정렬과 같은 작업을 수행하는 등
리스트를 더욱 편리하게 다룰 수 있습니다.

\begin{notebox}
리스트는 \textbf{뮤터블(mutable)}한 자료형입니다.
따라서 많은 리스트 메서드들은
리스트 객체 자체를 직접 변경합니다(in-place).
이 경우 메서드의 반환값은 보통 \texttt{None}입니다.
\end{notebox}

\subsubsection{\texttt{append(x)}: 리스트 끝에 요소 추가}

\begin{conceptbox}
\texttt{append(x)} 메서드는
리스트의 맨 뒤에 요소 \texttt{x}를 하나 추가합니다.
가장 자주 사용되는 리스트 메서드 중 하나입니다.
\end{conceptbox}

\begin{examplebox}
\begin{lstlisting}
numbers = [1, 2, 3]
numbers.append(4)
print(numbers)
\end{lstlisting}

출력 결과:
\begin{verbatim}
[1, 2, 3, 4]
\end{verbatim}
\end{examplebox}

\subsubsection{\texttt{extend(iterable)}: 여러 요소 한 번에 추가}

\begin{conceptbox}
\texttt{extend(iterable)} 메서드는
리스트의 맨 뒤에 여러 요소를 한 번에 추가합니다.
여기서 \texttt{iterable}은
리스트처럼 여러 값을 순서대로 꺼낼 수 있는 자료구조를 의미합니다.
\end{conceptbox}

\begin{examplebox}
\begin{lstlisting}
a = [1, 2]
a.extend([3, 4, 5])
print(a)
\end{lstlisting}

출력 결과:
\begin{verbatim}
[1, 2, 3, 4, 5]
\end{verbatim}
\end{examplebox}

\begin{notebox}
\texttt{append()}는 요소 하나를 추가하지만,
\texttt{extend()}는 여러 요소를 펼쳐서 추가합니다.
\end{notebox}

\begin{examplebox}
\begin{lstlisting}
b = [1, 2]

b.append([3, 4])
print(b)

c = [1, 2]
c.extend([3, 4])
print(c)
\end{lstlisting}

출력 결과:
\begin{verbatim}
[1, 2, [3, 4]]
[1, 2, 3, 4]
\end{verbatim}
\end{examplebox}

\subsubsection{\texttt{insert(i, x)}: 원하는 위치에 삽입}

\begin{conceptbox}
\texttt{insert(i, x)} 메서드는
인덱스 \texttt{i} 위치에 요소 \texttt{x}를 삽입합니다.
삽입된 이후의 요소들은 한 칸씩 뒤로 밀립니다.
\end{conceptbox}

\begin{examplebox}
\begin{lstlisting}
nums = [10, 20, 30]
nums.insert(1, 15)
print(nums)
\end{lstlisting}

출력 결과:
\begin{verbatim}
[10, 15, 20, 30]
\end{verbatim}
\end{examplebox}

\subsubsection{\texttt{pop([i])}: 요소를 꺼내며 삭제}

\begin{conceptbox}
\texttt{pop()} 메서드는
리스트에서 요소를 제거하면서 그 값을 반환합니다.
인덱스를 생략하면 마지막 요소를 제거합니다.
\end{conceptbox}

\begin{examplebox}
\begin{lstlisting}
data = [1, 2, 3, 4]
x = data.pop()
y = data.pop(1)
print(x, y)
print(data)
\end{lstlisting}

출력 결과:
\begin{verbatim}
4 2
[1, 3]
\end{verbatim}
\end{examplebox}

\begin{notebox}
\texttt{pop()}은 값을 \textbf{반환}한다는 점에서
단순 삭제와 다릅니다.
\end{notebox}

\subsubsection{\texttt{remove(x)}: 값으로 삭제}

\begin{conceptbox}
\texttt{remove(x)} 메서드는
리스트에서 값이 \texttt{x}인 첫 번째 요소를 찾아 삭제합니다.
\end{conceptbox}

\begin{examplebox}
\begin{lstlisting}
vals = [1, 2, 3, 2]
vals.remove(2)
print(vals)
\end{lstlisting}

출력 결과:
\begin{verbatim}
[1, 3, 2]
\end{verbatim}
\end{examplebox}

\begin{notebox}
삭제하려는 값이 리스트에 없으면
\texttt{ValueError} 예외가 발생합니다.
\end{notebox}

\subsubsection{\texttt{clear()}: 모든 요소 삭제}

\begin{conceptbox}
\texttt{clear()} 메서드는
리스트의 모든 요소를 제거하여
빈 리스트로 만듭니다.
\end{conceptbox}

\begin{examplebox}
\begin{lstlisting}
items = [1, 2, 3]
items.clear()
print(items)
\end{lstlisting}

출력 결과:
\begin{verbatim}
[]
\end{verbatim}
\end{examplebox}

\subsubsection{\texttt{index(x)}: 값의 위치 찾기}

\begin{conceptbox}
\texttt{index(x)} 메서드는
리스트에서 값이 \texttt{x}인 요소의
첫 번째 인덱스를 반환합니다.
\end{conceptbox}

\begin{examplebox}
\begin{lstlisting}
arr = [10, 20, 30, 20]
print(arr.index(20))
\end{lstlisting}

출력 결과:
\begin{verbatim}
1
\end{verbatim}
\end{examplebox}

\begin{notebox}
찾는 값이 리스트에 없으면
\texttt{ValueError} 예외가 발생합니다.
\end{notebox}

\subsubsection{\texttt{count(x)}: 값의 개수 세기}

\begin{conceptbox}
\texttt{count(x)} 메서드는
리스트에서 값이 \texttt{x}인 요소의 개수를 반환합니다.
\end{conceptbox}

\begin{examplebox}
\begin{lstlisting}
arr = [1, 2, 2, 3, 2]
print(arr.count(2))
\end{lstlisting}

출력 결과:
\begin{verbatim}
3
\end{verbatim}
\end{examplebox}

\subsubsection{\texttt{sort()}와 \texttt{sorted()}: 정렬}

\begin{conceptbox}
리스트를 정렬하는 방법은 두 가지가 있습니다.

\begin{itemize}
    \item \texttt{list.sort()} : 리스트 자체를 정렬(in-place)
    \item \texttt{sorted(list)} : 정렬된 \textbf{새 리스트} 반환
\end{itemize}
\end{conceptbox}

\begin{examplebox}
\begin{lstlisting}
a = [3, 1, 2]
a.sort()
print(a)

b = [3, 1, 2]
c = sorted(b)
print(b)
print(c)
\end{lstlisting}

출력 결과:
\begin{verbatim}
[1, 2, 3]
[3, 1, 2]
[1, 2, 3]
\end{verbatim}
\end{examplebox}

\begin{notebox}
\texttt{sort()}는 반환값이 \texttt{None}입니다.
정렬된 리스트를 얻기 위해
\texttt{a = a.sort()}와 같이 작성하면
원하지 않는 결과가 나올 수 있으니 주의해야 합니다.
\end{notebox}

\subsubsection{\texttt{reverse()}: 순서 뒤집기}

\begin{conceptbox}
\texttt{reverse()} 메서드는
리스트 요소들의 순서를 뒤집습니다(in-place).
정렬이 아니라 단순히 순서를 반대로 만드는 동작입니다.
\end{conceptbox}

\begin{examplebox}
\begin{lstlisting}
a = [1, 2, 3]
a.reverse()
print(a)
\end{lstlisting}

출력 결과:
\begin{verbatim}
[3, 2, 1]
\end{verbatim}
\end{examplebox}

\subsubsection{\texttt{copy()}: 리스트 복사}

\begin{conceptbox}
\texttt{copy()} 메서드는
리스트의 얕은 복사(shallow copy)를 생성합니다.
즉, 겉의 리스트는 새로 만들지만,
중첩 리스트 같은 내부 객체는 공유될 수 있습니다.
\end{conceptbox}

\begin{examplebox}
\begin{lstlisting}
a = [1, 2, 3]
b = a.copy()
b[0] = 99
print(a)
print(b)
\end{lstlisting}

출력 결과:
\begin{verbatim}
[1, 2, 3]
[99, 2, 3]
\end{verbatim}
\end{examplebox}

\begin{notebox}
중첩 리스트를 복사할 때는
얕은 복사로 인해
원본과 복사본이 내부 리스트를 공유할 수 있습니다.
\end{notebox}

\begin{readernotebox}
다음 질문에 답하며 리스트 메서드를 정리해 보세요.

\begin{itemize}
    \item \texttt{append()}와 \texttt{extend()}의 차이점은 무엇인가?
    \vspace{1.2cm}

    \item \texttt{pop()}과 \texttt{remove()}의 차이점은 무엇인가?
    \vspace{1.2cm}

    \item \texttt{sort()}와 \texttt{sorted()}의 차이점은 무엇인가?
    \vfill
\end{itemize}
\end{readernotebox}

\subsection{메서드의 옵션(option)}

일부 리스트 메서드들은
단순한 동작 외에도
\textbf{옵션(option)}을 통해
동작 방식을 세밀하게 조정할 수 있습니다.
옵션은 메서드 괄호 안에
추가 인자로 전달됩니다.

\subsubsection{\texttt{sort()} 메서드의 옵션}

\begin{conceptbox}
\texttt{sort()} 메서드는
옵션을 사용하여
정렬 기준과 정렬 방향을 지정할 수 있습니다.
\end{conceptbox}

\begin{itemize}
    \item \texttt{reverse=True} : 내림차순 정렬
    \item \texttt{key=} : 정렬 기준을 지정
\end{itemize}

\begin{examplebox}
\begin{lstlisting}
nums = [5, 1, 3, 2]
nums.sort(reverse=True)
print(nums)
\end{lstlisting}

출력 결과:
\begin{verbatim}
[5, 3, 2, 1]
\end{verbatim}
\end{examplebox}

다음은 \texttt{key} 옵션을 사용하여
각 요소의 길이를 기준으로
문자열 리스트를 정렬하는 예시입니다.

\begin{examplebox}
\begin{lstlisting}
words = ["banana", "kiwi", "apple"]
words.sort(key=len)
print(words)
\end{lstlisting}

출력 결과:
\begin{verbatim}
['kiwi', 'apple', 'banana']
\end{verbatim}
\end{examplebox}

\begin{notebox}
\texttt{key} 옵션에는
각 요소를 하나의 값으로 변환하는
함수를 전달합니다.
정렬은 이 변환된 값을 기준으로 수행됩니다.
\end{notebox}
본 교재에서 소개한 옵션 외에도,
다양한 리스트 메서드에는
여러 추가 옵션들이 존재합니다.
더 깊이 있는 내용을 학습하고 싶은 독자께서는
Python 공식 문서를 참고하시기 바랍니다.

\subsection{얕은 복사(shallow copy)와 깊은 복사(deep copy)}

리스트를 복사할 때는
\textbf{얕은 복사}와
\textbf{깊은 복사}를 구분해야 합니다.
이 차이는
리스트 안에 또 다른 리스트가 있을 때
특히 중요해집니다.

\begin{conceptbox}
얕은 복사(shallow copy)는
리스트 객체 자체는 새로 생성하지만,
리스트 내부의 요소들은
원본과 공유합니다.
\end{conceptbox}

\begin{examplebox}
\begin{lstlisting}
a = [[1, 2], [3, 4]]
b = a.copy()

b[0][0] = 99
print(a)
print(b)
\end{lstlisting}

출력 결과:
\begin{verbatim}
[[99, 2], [3, 4]]
[[99, 2], [3, 4]]
\end{verbatim}
\end{examplebox}

위 예시에서 볼 수 있듯이,
얕은 복사에서는
중첩된 리스트가
원본과 복사본 사이에서 공유됩니다.

\begin{conceptbox}
깊은 복사(deep copy)는
리스트 내부의 모든 요소까지
완전히 새로운 객체로 복사합니다.
\end{conceptbox}

깊은 복사를 수행하기 위해서는
\texttt{copy} 모듈의
\texttt{deepcopy()} 함수를 사용합니다.

\begin{examplebox}
\begin{lstlisting}
import copy

a = [[1, 2], [3, 4]]
b = copy.deepcopy(a)

b[0][0] = 99
print(a)
print(b)
\end{lstlisting}

출력 결과:
\begin{verbatim}
[[1, 2], [3, 4]]
[[99, 2], [3, 4]]
\end{verbatim}
\end{examplebox}

\begin{notebox}
리스트 안에
기본 자료형만 포함되어 있다면
얕은 복사로 충분한 경우가 많습니다.
그러나 중첩 리스트를 다룰 때는
깊은 복사가 필요한지
항상 고민해야 합니다.
\end{notebox}