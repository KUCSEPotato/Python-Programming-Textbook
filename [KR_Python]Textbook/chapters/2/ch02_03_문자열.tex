% ========================================
% 2.3
% ========================================
\section{문자열 자료형(String)}
\begin{conceptbox}
문자열(String)이란 \textbf{문자들의 나열로 이루어진 자료}를 의미합니다.
문자열은 주로 텍스트 데이터를 표현하는 데 사용되며,
\texttt{"안녕하세요"}, \texttt{"Python"}과 같은 값들이 문자열의 예시입니다.
\end{conceptbox}

문자열은 사용자 입력, 출력 메시지, 파일 내용 등
프로그램에서 가장 자주 다루는 자료형 중 하나입니다.
숫자와 달리 문자열은 계산의 대상이 아니라
문자의 집합으로서 처리되며, 문자열을 다루는 방법을 이해하는 것은
프로그래밍의 기본적인 흐름을 익히는 데 매우 중요합니다.

이 절에서는 Python에서 문자열을 생성하는 방법부터 시작하여,
문자열을 구성하고 활용하는 기초적인 방법들을 차례대로 살펴보겠습니다.

% ========================================
% 2.3.1
% ========================================
\subsection{문자열을 만드는 방법}

Python에서는 문자열을 만들기 위해 두 가지 따옴표를 사용할 수 있습니다.

\begin{enumerate}
    \item \textbf{큰따옴표(" ")를 사용한 문자열}
\begin{examplebox}
\begin{lstlisting}
str1 = "Hello."
print(str1)
\end{lstlisting}

출력 결과:
\begin{verbatim}
Hello.
\end{verbatim}

\end{examplebox}

    \item \textbf{작은따옴표(' ')를 사용한 문자열}
\begin{examplebox}
\begin{lstlisting}
str1 = 'Hello.'
print(str1)
\end{lstlisting}

출력 결과:
\begin{verbatim}
Hello.
\end{verbatim}

\end{examplebox}
\end{enumerate}

% ========================================
% 2.3.1.1
% ========================================
\subsubsection{문자열 내부에 따옴표 넣기}

문자열을 만들 때 사용한 따옴표와 동일한 따옴표를 문자열 내부에 그대로 사용하면
Python은 이를 문자열의 끝으로 인식하여 구문 오류(Syntax Error)가 발생합니다.

\begin{examplebox}
\begin{lstlisting}
str1 = ""Hello" was spoken"
\end{lstlisting}

출력 결과:
\begin{verbatim}
SyntaxError: invalid syntax
\end{verbatim}

\end{examplebox}

이는 Python이 위 코드를 여러 개의 문자열이 나열된 것으로 잘못 해석하기 때문입니다.
이러한 경우에는 \textbf{다른 종류의 따옴표}를 사용하여 문자열을 만들 수 있습니다.

\begin{examplebox}
\begin{lstlisting}
str1 = '"Hello" was spoken'
str2 = "'Hello' was thought"

print(str1)
print(str2)
\end{lstlisting}

출력 결과:
\begin{verbatim}
"Hello" was spoken
'Hello' was thought
\end{verbatim}

\end{examplebox}

% ========================================
% 2.3.1.2
% ========================================
\subsubsection{이스케이프 문자(Escape Character)}

이스케이프 문자는 역슬래시(\textbackslash)와 함께 사용되는 특수 문자로,
따옴표를 문자열의 일부로 표현하고 싶을 때 사용할 수 있습니다.

\begin{examplebox}
\begin{lstlisting}
str1 = "\"Hello\" was spoken."
print(str1)
\end{lstlisting}

출력 결과:
\begin{verbatim}
"Hello" was spoken.
\end{verbatim}

\end{examplebox}

이스케이프 문자는 따옴표를 단순한 문자로 표현하는 것 외에도,
문자열 내에서 특수한 동작을 수행하기 위해 다양한 용도로 사용됩니다.
자주 사용되는 이스케이프 문자는 다음과 같습니다.

\begin{itemize}
    \item \texttt{\textbackslash n} : 줄 바꿈(new line)을 의미합니다.
    \item \texttt{\textbackslash t} : 탭(tab), 즉 들여쓰기를 의미합니다.
    \item \texttt{\textbackslash\textbackslash} : 역슬래시(\textbackslash) 문자 자체를 출력할 때 사용합니다.
\end{itemize}
참고로 한국어 키보드에서 역슬래시는 원화 기호 입니다.


% ========================================
% 2.3.1.3
% ========================================
\subsubsection{여러 줄 문자열}
Python에서는 여러 줄에 걸친 문자열을 표현하기 위해 세 개의 따옴표를 사용할 수 있습니다.
\begin{itemize}
    \item \textbf{"""(contents)"""}
    \item \textbf{'''(contents)'''}
\end{itemize}
여러 줄 문자열은 활용도가 매우 높아 앞으로 프로그램을 작성하면서 자주 사용하게 될 것입니다.
\begin{examplebox}
\begin{lstlisting}
# Declare string
str1 = """Until the waters of the East Sea dry up
and Mount Baekdu wears away,
may God watch over and protect our nation."""
str2 = """Three thousand li of splendid rivers and mountains,
great Korean people,
may our nation endure forever."""

# print
print(str1)
print(str2)
\end{lstlisting}

출력 결과:
\begin{verbatim}
Until the waters of the East Sea dry up
and Mount Baekdu wears away,
may God watch over and protect our nation.
Three thousand li of splendid rivers and mountains,
great Korean people,
may our nation endure forever.
\end{verbatim}

\end{examplebox}
이때 코드의 가독성을 위해서 아래처럼 줄 바꿈을 사용하여 작성할 수 있습니다. 
그러나 이 경우에는 출력할 때 의도하지 않은 줄 바꿈이 들어갈 수 있습니다.
이런 의도하지 않은 줄 바꿈은 \texttt{\textbackslash}를 사용하여 없앨 수 있습니다.
이를 통해 우리는 Python에게 "가독성을 위한 것이지 줄바꿈을 의도한 것은 아니다."라는 것을 전달 할 수 있습니다.

\begin{examplebox}
\begin{lstlisting}
# Declare string
str1 = """
Until the waters of the East Sea dry up
and Mount Baekdu wears away,
may God watch over and protect our nation.
"""

# print
print(str1)
\end{lstlisting}

출력 결과:
\begin{verbatim}
[공백]
Until the waters of the East Sea dry up
and Mount Baekdu wears away,
may God watch over and protect our nation.
[공백]
\end{verbatim}

\end{examplebox}

위 예시에서는 출력 결과에 \textbf{위와 아래에 빈 줄이 포함되어 있음을 명확히 보여주기 위해} 설명용으로 \texttt{[공백]}이라는 표시를 삽입하였습니다.
실제 프로그램 실행 결과에는 \texttt{[공백]}이라는 문자열이 출력되지 않으며, 단순히 빈 줄만 출력됩니다.
따라서 실행 결과에 \texttt{[공백]}이라는 글자가 보이지 않더라도 정상적인 동작이므로 혼동하지 않도록 주의하시기 바랍니다.

\begin{notebox}
직전 예시와 아래 예시의 차이점을
\textit{(1) 문자열의 선언 방식과 (2) \texttt{print} 함수의 출력 결과}를 중심으로 비교해 보세요.
예제 코드는 Appendix의 GitHub링크에서 확인할 수 있으며, 직접 실행해 보는 것이 이해에 큰 도움이 됩니다.
\end{notebox}

\begin{examplebox}
\begin{lstlisting}
# Declare string using backslash
str2 = """\
Three thousand li of splendid rivers and mountains,
great Korean people,
may our nation endure forever.\
"""

# print
print(str2)
\end{lstlisting}

출력 결과:
\begin{verbatim}
Three thousand li of splendid rivers and mountains,
great Korean people,
may our nation endure forever.
\end{verbatim}

\end{examplebox}

\begin{notebox}
문자열을 만들 때 따옴표로 글자를 감싼다고 배웠습니다.
이처럼 \textbf{프로그램 코드에 따옴표로 직접 작성된 문자열 값}을
\textbf{문자열 리터럴(string literal)}이라고 부릅니다.

즉, 문자열 리터럴은 실행 시 문자열 객체로 생성되는
가장 기본적인 형태의 문자열 표현입니다.
이후 본 교과서에서 \textit{문자열 리터럴}이라는 용어가 등장하더라도,
따옴표로 표현된 문자열을 의미한다고 이해하면 됩니다.
\end{notebox}

\begin{notebox}
여러 줄 문자열은 단순히 여러 줄의 텍스트를 저장하는 데에만 사용되는 것이 아니라,
개발자가 정의한 함수에 대한 설명을 작성하는 용도로도 활용됩니다.
이와 관련된 내용은 \texttt{Chapter 5. Function}에서 자세히 다룹니다.
\end{notebox}

% ========================================
% 2.3.2
% ========================================
\subsection{문자열 연산자}

\begin{conceptbox}
Python에서 연산자는 모든 자료형에 대해 동일하게 동작하지 않습니다.
각 연산자는 특정 자료형에 대해서만 의미가 정의되어 있으며,
이를 \textbf{연산자가 자료형에 종속된다}고 표현합니다.
\end{conceptbox}

문자열(\texttt{str}) 자료형 역시 고유한 연산자 동작 방식을 가지며,
본 절에서는 문자열에 적용할 수 있는 주요 연산자들을 살펴봅니다.

% ========================================
% 2.3.2.1
% ========================================
\subsubsection{문자열 연결 연산자 (\texttt{+})}

\begin{conceptbox}
문자열에 \texttt{+} 연산자를 사용하면
두 문자열을 순서대로 이어 붙인 \textbf{새로운 문자열}이 생성됩니다.
이 연산은 수학적 덧셈과 달리,
문자열의 내용을 결합하는 동작을 수행합니다.
\end{conceptbox}

\begin{examplebox}
\begin{lstlisting}
str1 = "Hello"
str2 = "Everyone"
print(str1 + str2)
\end{lstlisting}

출력 결과:
\begin{verbatim}
HelloEveryone
\end{verbatim}
\end{examplebox}

\begin{notebox}
문자열 연결 연산은 문자열 자료형에 대해서만 정의되어 있습니다.
문자열과 숫자처럼 서로 다른 자료형을 직접 연결하려 하면
\texttt{TypeError}가 발생합니다.
\end{notebox}

\begin{examplebox}
\begin{lstlisting}
str1 = "Hello"
str2 = "Everyone"
print(str1 + str2 + 1)
\end{lstlisting}

출력 결과:
\begin{verbatim}
TypeError: can only concatenate str (not "int") to str
\end{verbatim}
\end{examplebox}

문자열과 숫자를 함께 출력하고 싶을 경우,
숫자를 문자열로 변환해야 합니다.
이는 문자열 연결 연산이
\textbf{문자열 객체 간의 연산}으로만 정의되어 있기 때문입니다.

숫자를 문자열로 변환하는 방법에는 크게 두 가지가 있습니다.
첫 번째는 숫자를 따옴표로 감싸
\textbf{문자열 리터럴}로 표현하는 방법이고,
두 번째는 Python에서 제공하는 \texttt{str()} 함수를 사용하는 방법입니다.

다음 예시는 첫 번째 방법을 사용한 경우입니다.

\begin{examplebox}
\begin{lstlisting}
str1 = "Hello"
str2 = "Everyone"
print(str1 + str2 + "1")
\end{lstlisting}

출력 결과:
\begin{verbatim}
HelloEveryone1
\end{verbatim}
\end{examplebox}

\begin{notebox}
\texttt{str()} 함수는 주어진 값을 문자열(\texttt{str})로 변환합니다.
\texttt{print()} 함수는 내부적으로 출력할 대상을 문자열로 변환하기 때문에,
명시적으로 문자열 변환이 필요할 때 \texttt{str()} 함수가 자주 사용됩니다.
\end{notebox}

\begin{exercisebox}
아래 코드를 str함수를 사용하여 정상적으로 작동하도록 수정해보세요.
\begin{lstlisting}
str1 = "Hello"
str2 = "Everyone"
print(str1 + str2 + 1)
\end{lstlisting}

\end{exercisebox}

% ========================================
% 2.3.2.2
% ========================================
\subsubsection{문자열 반복 연산자 (\texttt{*})}

\begin{conceptbox}
문자열과 정수 사이에 \texttt{*} 연산자를 사용하면
문자열 반복 연산이 수행됩니다.
이 연산은 문자열을 지정된 횟수만큼 반복하여
하나의 새로운 문자열을 생성합니다.
\end{conceptbox}

\begin{examplebox}
\begin{lstlisting}
str1 = "Hello"
print(str1 * 3)
print(4 * str1)
\end{lstlisting}

출력 결과:
\begin{verbatim}
HelloHelloHello
HelloHelloHelloHello
\end{verbatim}
\end{examplebox}

\begin{notebox}
문자열 반복 연산자는 반드시 \textbf{정수}와 함께 사용해야 합니다.
실수와 함께 사용할 경우 반복 횟수가 정의되지 않으므로 오류가 발생합니다.
Python에서 정수형과 실수형의 차이는 \textttt{2.4 숫자 자료형}에서 학습합니다.
\end{notebox}

% ========================================
% 2.3.2.3
% ========================================
\subsubsection{문자 선택 연산자 (인덱싱, \texttt{[]})}

문자 선택 연산자(인덱싱, \texttt{[]})를 배우기에 앞서,
프로그래밍 언어에서 사용되는 인덱스 방식에 대해 먼저 알아야 합니다.
프로그래밍 언어의 인덱스 방식에는 \textbf{one index}와 \textbf{zero index}가 있습니다.
\textbf{one index} 방식은 첫 번째 요소의 인덱스를 1로 두는 방식이며,
\textbf{zero index} 방식은 첫 번째 요소의 인덱스를 0으로 두는 방식입니다.
Python을 포함한 대부분의 현대 프로그래밍 언어는 zero index 방식을 채택하고 있습니다.
이제 문자 선택 연산자에 대해 알아봅시다.

\begin{conceptbox}
문자 선택 연산자(인덱싱)는 문자열 내부의 특정 문자 하나를 선택하는 연산자입니다.
대괄호 \texttt{[]} 안에 정수 인덱스를 지정하여 문자를 선택하며,
Python은 \textbf{제로 인덱스(zero index)} 방식을 사용합니다.
\end{conceptbox}

\begin{examplebox}
\begin{lstlisting}
text = "Hello"

print(text[0])
print(text[1])
print(text[4])
\end{lstlisting}

출력 결과:
\begin{verbatim}
H
e
o
\end{verbatim}
\end{examplebox}

문자 선택 연산을 위해서는 정수만을 사용해야 합니다.
앞선 예시에서는 양의 정수만을 사용하였지만, 음의 정수를 사용하면 어떤 일이 발생할까요?

\begin{conceptbox}
인덱스에 음수를 사용하면 문자열의 끝에서부터 문자를 선택합니다.
\end{conceptbox}

\begin{examplebox}
\begin{lstlisting}
text = "Hello"

print(text[-1])
print(text[-4])
print(text[-5])
\end{lstlisting}

출력 결과:
\begin{verbatim}
o
e
H
\end{verbatim}
\end{examplebox}

\begin{notebox}
본 교재에서는 용어의 통일을 위해 \texttt{문자 선택 연산자}라는 표현을 사용하지만,
실제로는 문자열 인덱싱(\textit{string indexing}) 또는 인덱싱(\textit{indexing})이라는 용어가 더 자주 사용됩니다.
이후 본 교재에서는 문자열 인덱싱 또는 인덱싱이라는 용어를 사용합니다.
\end{notebox}

% ========================================
% 2.3.2.4
% ========================================
\subsubsection{문자열 범위 선택 연산자 (슬라이싱, \texttt{[:]})}

문자열 선택 연산자는 문자열에서 하나의 문자를 선택하는 것이라면, 문자열 범위 선택 연산자는 문자열의 일부를 가져오는 것입니다.

\begin{conceptbox}
문자열 범위 선택 연산자은 문자열의 연속된 일부 범위를 선택하는 연산자입니다.
대괄호 안에 시작 인덱스와 종료 인덱스를 콜론(\texttt{:})으로 구분하여 지정합니다.

Python의 문자열 범위 선택 연산자는 \textbf{종료 인덱스를 포함하지 않습니다}.
즉, \texttt{[n:k]}는 인덱스 \texttt{n}부터 \texttt{k-1}까지의 문자를 선택합니다.
\end{conceptbox}

\begin{examplebox}
\begin{lstlisting}
text = "HelloWorld"

print(text[1:4])
\end{lstlisting}

출력 결과:
\begin{verbatim}
ell
\end{verbatim}
\end{examplebox}

\begin{examplebox}
\begin{lstlisting}
text = "HelloWorld"

print(text[0:5])
print(text[5:10])
\end{lstlisting}

출력 결과:
\begin{verbatim}
Hello
World
\end{verbatim}
\end{examplebox}

만약 종료 인덱스보다 시작 인덱스가 더 크다면 어떻게 될까요?
\begin{notebox}
만약 시작 인덱스가 종료 인덱스보다 크다면,
선택할 수 있는 범위가 존재하지 않으므로
빈 문자열이 반환됩니다.
\end{notebox}

\begin{examplebox}
\begin{lstlisting}
text = "HelloWorld"

print(text[5:3])
\end{lstlisting}

출력 결과:
\begin{verbatim}

\end{verbatim}
\end{examplebox}

\begin{conceptbox}
문자열 범위 선택 연산자에서는 시작 인덱스 또는 종료 인덱스를 생략할 수 있습니다.
시작 인덱스를 생략하면 문자열의 처음부터,
종료 인덱스를 생략하면 문자열의 끝까지 선택합니다.
\end{conceptbox}

\begin{examplebox}
\begin{lstlisting}
text = "HelloWorld"

print(text[5:])
print(text[:5])
print(text[:])
print(text[:-1])
\end{lstlisting}

출력 결과:
\begin{verbatim}
World
Hello
HelloWorld
HelloWorl
\end{verbatim}
\end{examplebox}

\begin{notebox}
본 교재에서는 용어의 통일을 위해 \texttt{문자열 범위 선택 연산자}라는 표현을 사용하지만,
실제로는 문자열 슬라이싱(\textit{string slicing}) 또는 슬라이싱(\textit{slicing})이라는 용어가 더 자주 사용됩니다.
이후 본 교재에서는 문자열 슬라이싱 또는 슬라이싱이라는 용어를 사용합니다.
\end{notebox}

만약 마지막 예시에서 \texttt{text[:-1]}이
시작 인덱스가 종료 인덱스보다 큰 경우가 아닌지 궁금하신 독자분들께서는
다음 노트를 읽어보시기 바랍니다.
그렇지 않은 독자분들은 넘어가셔도 좋습니다.

\begin{notebox}
수학적으로는 \texttt{0 > -1}이 맞지만,
Python의 슬라이싱에서는 단순한 수치 비교를 먼저 수행하지 않습니다.
슬라이싱에서는 인덱스를 해석하는 과정에서
생략된 인덱스는 기본값으로 보완되고,
음수 인덱스는 문자열의 길이를 기준으로 변환됩니다.

따라서 \texttt{[:-1]}은 \texttt{[0:-1]}과 동일하며,
이는 다시 \texttt{[0:len(s)-1]}로 해석됩니다.
그 결과, 문자열의 처음부터 마지막 문자를 제외한 부분이 선택됩니다.
\end{notebox}

다음 노트부터는 모든 독자분들께서 읽어보시길 권장드립니다. 인덱싱과 슬라이싱에 대해 한 층 더 깊은 이해를 하실 수 있습니다.

\begin{notebox}
\texttt{len()} 함수는 문자열에 포함된 문자의 개수를 반환합니다.
즉, 괄호 내부에 문자열을 넣으면 ‘문자열에 들어있는 문자의 개수(=문자열의 길이)’를 세어 줍니다. 
슬라이싱에서 종료 인덱스가 생략되거나 음수 인덱스가 사용될 때,
Python은 내부적으로 \texttt{len()} 값을 기준으로 인덱스를 해석합니다.
\end{notebox}

\begin{notebox}
\texttt{[0:0]}은 시작 인덱스와 종료 인덱스가 동일한 경우입니다.
이 경우 선택할 수 있는 범위가 존재하지 않으므로,
결과로 빈 문자열이 반환됩니다.
이는 오류가 아니라 정상적인 슬라이싱 결과입니다.
\end{notebox}

\begin{notebox}
프로그래밍 도중 \texttt{IndexError (index out of range)} 예외를 마주할 수 있습니다.
이 예외는 인덱싱처럼 단일 인덱스로 문자열에 접근할 때,
존재하지 않는 위치의 문자를 요청하면 발생합니다.
좀 더 쉽게 설명드리자면, IndexError 예외는 리스트/문자열의 수를 넘는 요소/글자를 선택할 때 발생합니다.

반면, 슬라이싱은 범위를 벗어나더라도 예외를 발생시키지 않으며,
가능한 범위 내의 결과(또는 빈 문자열)를 반환합니다.
\end{notebox}

\begin{readernotebox}
다음 질문에 답하며 문자열 연산자를 정리해 보세요.

\begin{itemize}
    \item 문자열 연결 연산과 반복 연산은 어떤 공통점과 차이점을 가지는가?
    \item 인덱싱과 슬라이싱은 각각 어떤 상황에서 사용하는 것이 적절한가?
    \item 문자열 연산에서 자료형이 중요한 이유는 무엇인가?
    \vfill
\end{itemize}
\end{readernotebox}

\begin{exercisebox}
아래 예제 코드들의 실행 결과를 작성해보세요.
만약 실행 중 에러가 발생한다면, 해당 에러의 이름을 작성하세요.

\medskip
\noindent\textbf{(1)}
\begin{lstlisting}
text = "Python"
print(text[0])
\end{lstlisting}
실행 결과: 

\medskip
\noindent\textbf{(2)}
\begin{lstlisting}
text = "Python"
print(text[-1])
\end{lstlisting}
실행 결과:

\medskip
\noindent\textbf{(3)}
\begin{lstlisting}
text = "Python"
print(text[1:4])
\end{lstlisting}
실행 결과:

\medskip
\noindent\textbf{(4)}
\begin{lstlisting}
text = "Python"
print(text[:3])
print(text[3:])
\end{lstlisting}
실행 결과: 
\\

\medskip
\noindent\textbf{(5)}
\begin{lstlisting}
text = "Python"
print(text[:-1])
\end{lstlisting}
실행 결과: 

\medskip
\noindent\textbf{(6)}
\begin{lstlisting}
text = "Python"
print(text[2:2])
\end{lstlisting}
실행 결과: 

\medskip
\noindent\textbf{(7)}
\begin{lstlisting}
text = "Python"
print(text[len(text)-1])
\end{lstlisting}
실행 결과:

\medskip
\noindent\textbf{(8)}
\begin{lstlisting}
text = "Python"
print(text[len(text)])
\end{lstlisting}
실행 결과 또는 에러명: 
\end{exercisebox}

% ========================================
% 2.3.3
% ========================================
\subsection{문자열 자료형 메서드}

지금까지 문자열에 적용할 수 있는 기본적인 연산자들을 살펴보았습니다.
이러한 연산자들은 문자열을 결합하거나
특정 위치의 문자를 선택하는 등,
문자열을 다루는 가장 기본적인 기능을 제공합니다.

이번 절에서는 문자열 객체가 제공하는
\textbf{문자열 메서드(method)}에 대해 살펴봅니다.
문자열 메서드를 사용하면
문자열의 형태를 변환하거나
특정 기준에 따라 문자열을 처리하는 등,
연산자보다 더 다양한 작업을 수행할 수 있습니다.


% ========================================
% 2.3.3.1
% ========================================
\subsubsection{대소문자 변환 메서드}

\begin{conceptbox}
문자열에는 알파벳의 대소문자를 변환하기 위한 메서드들이 제공됩니다.
이 메서드들은 문자열의 내용을 변경하는 것이 아니라,
\textbf{변환된 새로운 문자열을 반환}합니다.
\end{conceptbox}

\begin{itemize}
    \item \texttt{upper()} : 모든 문자를 대문자로 변환
    \item \texttt{lower()} : 모든 문자를 소문자로 변환
    \item \texttt{capitalize()} : 첫 문자만 대문자로 변환
    \item \texttt{swapcase()}: 대소문자 상호 변환
\end{itemize}

문자열 메서드는 변환하고 싶은 문자열 뒤에
\texttt{.}을 붙인 후 메서드 이름을 작성하여 사용할 수 있습니다.
아래 예시를 통해 문자열 메서드의 사용 방법을
보다 자세히 살펴보겠습니다.

\begin{examplebox}
\begin{lstlisting}
text = "python programming"
text2 = "AppLe"

print(text.upper())
print(text.lower())
print(text.capitalize())
print(text2.swapcase())
\end{lstlisting}

출력 결과:
\begin{verbatim}
PYTHON PROGRAMMING
python programming
Python programming
aPPlE

\end{verbatim}
\end{examplebox}

\begin{notebox}
문자열은 변경 불가능한(immutable) 자료형이므로,
위 메서드들은 원본 문자열을 수정하지 않습니다.
변환 결과를 사용하려면 반환값을 변수에 저장해야 합니다.
\end{notebox}

% ========================================
% 2.3.3.2
% ========================================
\subsubsection{공백 제거 메서드}

\begin{conceptbox}
문자열의 앞이나 뒤에 불필요한 공백이 포함된 경우,
이를 제거하기 위한 메서드들을 사용할 수 있습니다.
입력 데이터 처리에서 자주 사용되는 메서드들입니다.
\end{conceptbox}

\begin{itemize}
    \item \texttt{strip()}  : 양쪽 공백 제거
    \item \texttt{lstrip()} : 왼쪽 공백 제거
    \item \texttt{rstrip()} : 오른쪽 공백 제거
\end{itemize}

\begin{examplebox}
\begin{lstlisting}
text = "   Hello World   "

print(text.strip())
print(text.lstrip())
print(text.rstrip())
\end{lstlisting}

출력 결과:
\begin{verbatim}
Hello World
Hello World   
   Hello World
\end{verbatim}
\end{examplebox}

\begin{notebox}
텍스트 데이터를 다루는 머신러닝/딥러닝에서는
입력 데이터의 작은 차이도 중요한 의미를 가질 수 있습니다.
문자열의 앞뒤 공백은 사람이 보기에는 같아 보여도,
컴퓨터에게는 서로 다른 값으로 인식될 수 있으므로
사전에 제거하는 것이 일반적입니다.
\end{notebox}

\begin{readernotebox}

\end{readernotebox}

% ========================================
% 2.3.3.3
% ========================================
\subsubsection{문자열 분리 메서드}

\begin{conceptbox}
문자열을 특정 기준에 따라 여러 부분으로 나누고 싶을 때
문자열 분리 메서드를 사용할 수 있습니다.
이 메서드는 문자열을 분리하여
\textbf{리스트(list)} 형태로 반환합니다.
\end{conceptbox}

\begin{itemize}
    \item \texttt{split()} : 지정한 구분자를 기준으로 문자열 분리
\end{itemize}

\begin{examplebox}
\begin{lstlisting}
text = "apple,banana,orange"

result = text.split(",")
print(result)
\end{lstlisting}

출력 결과:
\begin{verbatim}
['apple', 'banana', 'orange']
\end{verbatim}
\end{examplebox}

\begin{notebox}
\texttt{split()} 메서드의 결과는 문자열이 아닌 리스트입니다.
따라서 이후에는 리스트에 사용할 수 있는 연산자나 메서드를 사용해야 합니다.
\end{notebox}

% ========================================
% 2.3.3.4
% ========================================
\subsubsection{문자열 치환 메서드}

\begin{conceptbox}
문자열의 특정 부분을 다른 문자열로 바꾸고 싶을 때
문자열 치환 메서드를 사용할 수 있습니다.
\end{conceptbox}

\begin{itemize}
    \item \texttt{replace(old, new)} :
    문자열에서 \texttt{old}를 찾아 \texttt{new}로 치환
\end{itemize}

\begin{examplebox}
\begin{lstlisting}
text = "I like Python"

new_text = text.replace("Python", "Programming")
print(new_text)
\end{lstlisting}

출력 결과:
\begin{verbatim}
I like Programming
\end{verbatim}
\end{examplebox}

\begin{notebox}
\texttt{replace()} 메서드 역시
원본 문자열을 변경하지 않고
치환된 새로운 문자열을 반환합니다.
\end{notebox}

% ========================================
% 2.3.3.5
% ========================================
\subsubsection{문자열 결합 메서드 \texttt{join()}}

\begin{conceptbox}
\texttt{join()} 메서드는
여러 개의 문자열을 하나의 문자열로
결합할 때 사용하는 문자열 메서드입니다.
이때 \texttt{join()}은
\textbf{결합 기준이 되는 문자열}에 속한 메서드라는 점에 주의해야 합니다.
\end{conceptbox}

\texttt{join()} 메서드는
문자열들의 모음(리스트, 튜플 등)을 인자로 받아,
각 문자열 사이에
기준 문자열을 삽입하여
하나의 문자열로 결합합니다.

\begin{examplebox}
\begin{lstlisting}
words = ["Hello", "World", "Python"]
result = " ".join(words)
print(result)
\end{lstlisting}

출력 결과:
\begin{verbatim}
Hello World Python
\end{verbatim}
\end{examplebox}

위 예시에서
공백 문자열 \texttt{" "}이
각 단어 사이에 삽입되어
문자열이 결합됩니다.

\begin{examplebox}
\begin{lstlisting}
numbers = ["1", "2", "3"]
print(",".join(numbers))
\end{lstlisting}

출력 결과:
\begin{verbatim}
1,2,3
\end{verbatim}
\end{examplebox}

\begin{notebox}
\texttt{join()} 메서드는
문자열만을 요소로 가지는 자료구조에 대해서만
사용할 수 있습니다.
문자열이 아닌 값이 포함되어 있을 경우,
\texttt{TypeError}가 발생합니다.
\end{notebox}

\begin{examplebox}
\begin{lstlisting}
values = [1, 2, 3]
print(",".join(values))
\end{lstlisting}

출력 결과:
\begin{verbatim}
TypeError: sequence item 0: expected str instance, int found
\end{verbatim}
\end{examplebox}

\begin{readernotebox}

\end{readernotebox}

% ========================================
% 2.3.3.6
% ========================================
\subsubsection{문자열 찾기 메서드}
\begin{conceptbox}
\texttt{count()} 메서드는
문자열에서 특정 문자열이
몇 번 등장하는지를 세어
그 개수를 반환합니다.
\end{conceptbox}

\begin{examplebox}
\begin{lstlisting}
sentence = "Say Hello at the early morning"
count1 = sentence.count("o")
count2 = sentence.count("at")
print(count1, count2)
\end{lstlisting}

출력 결과:
\begin{verbatim}
2 1
\end{verbatim}
\end{examplebox}

\begin{conceptbox}
\texttt{find()}와 \texttt{index()} 메서드는
문자열에서 특정 문자열이
처음 등장하는 위치(인덱스)를 반환합니다.
두 메서드의 차이점은
찾는 문자열이 없을 때의 동작입니다.
\end{conceptbox}

\begin{itemize}
    \item \texttt{find()} : 문자열이 없으면 \texttt{-1} 반환
    \item \texttt{index()} : 문자열이 없으면 예외 발생
\end{itemize}

\begin{examplebox}
\begin{lstlisting}
text = "C Python Rust"
print(text.find("Python"))
print(text.rfind("Python"))
\end{lstlisting}

출력 결과:
\begin{verbatim}
2
2
\end{verbatim}
\end{examplebox}

\begin{examplebox}
\begin{lstlisting}
print(text.find("Assembly"))
print(text.index("Assembly"))
\end{lstlisting}

출력 결과:
\begin{verbatim}
-1
ValueError: substring not found
\end{verbatim}
\end{examplebox}

\begin{conceptbox}
\texttt{startswith()}와 \texttt{endswith()} 메서드는
문자열이 특정 문자열로
시작하거나 끝나는지를 확인합니다.
반환값은 \texttt{True} 또는 \texttt{False}입니다.
\end{conceptbox}

\begin{examplebox}
\begin{lstlisting}
filename = "data.csv"
print(filename.startswith("data"))
print(filename.endswith(".csv"))
\end{lstlisting}

출력 결과:
\begin{verbatim}
True
True
\end{verbatim}
\end{examplebox}

\begin{conceptbox}
\texttt{in} 연산자는
문자열 내부에
특정 문자열이 포함되어 있는지를
간단하게 확인할 때 사용합니다.
\end{conceptbox}

\begin{examplebox}
\begin{lstlisting}
print("Python" in "I love Python")
print("Java" in "I love Python")
\end{lstlisting}

출력 결과:
\begin{verbatim}
True
False
\end{verbatim}
\end{examplebox}

% ========================================
% 2.3.3.7
% ========================================
\subsubsection{문자열의 구성 검사 메서드}

\begin{conceptbox}
\texttt{is}로 시작하는 문자열 메서드들은
문자열이 특정 조건을 만족하는지 여부를
\texttt{True} 또는 \texttt{False}로 반환합니다.
\end{conceptbox}

\begin{itemize}
    \item \texttt{isalnum()} : 문자 또는 숫자로만 구성
    \item \texttt{isalpha()} : 문자로만 구성
    \item \texttt{isdecimal()} : 정수 형태인지 확인
    \item \texttt{isdigit()} : 숫자로 인식 가능한지 확인
    \item \texttt{isspace()} : 공백 문자로만 구성
    \item \texttt{islower()} : 소문자로만 구성
    \item \texttt{isupper()} : 대문자로만 구성
    \item \texttt{isidentifier()} : 식별자로 사용 가능한지 확인
\end{itemize}


% ========================================
% 2.3.3.8
% ========================================
\subsubsection{문자열 포맷팅 메서드 \texttt{format()}}

\begin{conceptbox}
\texttt{format()} 메서드는
문자열 내부의 중괄호 \texttt{\{\}}를
지정한 값으로 치환하여
새로운 문자열을 생성합니다.
\end{conceptbox}

\begin{examplebox}
\begin{lstlisting}
print("{}".format(10))
print("{}, {}".format(10, 20))
\end{lstlisting}

출력 결과:
\begin{verbatim}
10
10, 20
\end{verbatim}
\end{examplebox}

\begin{notebox}
중괄호의 개수가
\texttt{format()}에 전달된 인자의 개수보다 많으면
\texttt{IndexError} 예외가 발생합니다.
\end{notebox}

\subsubsection{f-string}

\begin{conceptbox}
f-string은
문자열 앞에 \texttt{f}를 붙여
문자열 내부에
표현식을 직접 삽입할 수 있는 방식입니다.
\end{conceptbox}

\begin{examplebox}
\begin{lstlisting}
value = 10
print(f"Value is {value}")
print(f"3 + 4 = {3 + 4}")
\end{lstlisting}

출력 결과:
\begin{verbatim}
Value is 10
3 + 4 = 7
\end{verbatim}
\end{examplebox}

\begin{notebox}
f-string은 간결하고 직관적이기 때문에
Python 3.6 이후에는
가장 많이 사용되는 문자열 포맷팅 방식입니다.
\end{notebox}

\begin{readernotebox}

\end{readernotebox}

% ========================================
% 2.3.3.10
% ========================================
\subsubsection{심화: 문자열 연산자와 문자열 메서드의 차이가 무엇인가요?}

문자열을 다루는 방법에는 크게
\textbf{문자열 연산자}와 \textbf{문자열 메서드} 두 가지가 있습니다.
이 둘은 모두 문자열을 처리하는 데 사용되지만,
역할과 사용 방식에는 분명한 차이가 있습니다.

문자열 연산자는 \texttt{+}, \texttt{*}, \texttt{[]}, \texttt{[:]}와 같이
기호 형태로 제공되는 연산으로,
문자열을 결합하거나 반복하고,
특정 위치의 문자를 선택하는 등
\textbf{문자열에 대한 기본적인 조작}을 수행합니다.
이러한 연산자들은 \textbf{Python 문법 차원에서 제공되는 기능}입니다.

반면 문자열 메서드는
\textbf{문자열 객체가 스스로 제공하는 기능}으로,
\texttt{문자열.메서드()} 형태로 사용합니다.
문자열 메서드를 사용하면
대소문자 변환, 공백 제거, 문자열 분리, 문자열 치환 등
\textbf{보다 복잡하고 다양한 문자열 처리 작업}을 수행할 수 있습니다.

즉, 문자열 연산자는 문자열을 다루는 가장 기본적인 도구이고,
문자열 메서드는 문자열 객체가 제공하는 확장된 기능이라고 볼 수 있습니다.
프로그램의 목적과 처리하려는 작업의 종류에 따라
연산자와 메서드를 적절히 선택하여 사용하는 것이 중요합니다.

\begin{exercisebox}
다음은 하나의 문자열을 처리하는 종합 문제입니다.
지금까지 배운 문자열 메서드와 연산자를 활용하여
각 조건을 만족하는 코드를 작성해 보세요.

\begin{enumerate}
    \item 사용자로부터 하나의 문자열을 입력받는다.
    \item 입력된 문자열의 앞뒤 공백을 제거한다.
    \item 문자열 전체를 소문자로 변환한다.
    \item 문자열에 포함된 문자 \texttt{"python"}의 등장 횟수를 센다.
    \item 문자열이 \texttt{"python"}으로 시작하는지 확인한다.
    \item 문자열이 \texttt{"!"}로 끝나는지 확인한다.
    \item 문자열을 공백 기준으로 분리한 뒤,
    다시 하나의 문자열로 결합하되,
    각 단어 사이에 \texttt{"-"}를 삽입한다.
\end{enumerate}

각 단계에서 적절한 문자열 메서드를 사용하여 구현해 보세요.
\end{exercisebox}

\newpage
