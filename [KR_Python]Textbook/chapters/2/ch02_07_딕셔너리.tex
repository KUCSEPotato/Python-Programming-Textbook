% =========================================================
% \section{딕셔너리(Dictionary)}
% =========================================================
\section{딕셔너리(Dictionary)}

리스트와 튜플은
\textbf{인덱스(index)}를 사용하여 요소에 접근합니다.
하지만 현실의 데이터는 종종
``0번째, 1번째''처럼 접근하기보다,
``이름(name), 학번(id), 과목(course)''처럼
\textbf{의미 있는 키(key)}로 접근하는 것이 더 자연스럽습니다.

이럴 때 사용하는 자료형이
\textbf{딕셔너리(dictionary)}입니다.

\begin{conceptbox}
딕셔너리(dictionary)는
\textbf{키(key)와 값(value)}의 쌍으로 데이터를 저장하는 자료형입니다.
딕셔너리는 중괄호(\texttt{\{\}})로 생성하며,
\texttt{키: 값} 형태의 항목을 쉼표로 구분하여 나열합니다.

딕셔너리에서 값에 접근할 때는
인덱스가 아니라 \textbf{키(key)}를 사용합니다.
\end{conceptbox}

\begin{notebox}
딕셔너리는 \textbf{순서가 없는 자료형}으로 소개되는 경우가 많지만,
파이썬 3.7 이후(구현상 3.6부터)에서는 \textbf{삽입 순서가 유지}됩니다.
다만 딕셔너리의 핵심은 ``순서''가 아니라 ``키로 빠르게 접근''하는 것입니다.
\end{notebox}

\subsection{딕셔너리 생성하기}

\subsubsection{기본 생성}
\begin{examplebox}
\begin{lstlisting}
student = {
    "name": "Potato",
    "id": 2023320060,
    "major": "CS"
}

print(student["name"])
print(student["id"])
\end{lstlisting}

출력 결과:
\begin{verbatim}
Potato
2023320060
\end{verbatim}
\end{examplebox}

\subsubsection{빈 딕셔너리}
\begin{examplebox}
\begin{lstlisting}
d1 = {}
d2 = dict()
print(d1, type(d1))
\end{lstlisting}

출력 결과:
\begin{verbatim}
{} <class 'dict'>
\end{verbatim}
\end{examplebox}

\subsubsection{\texttt{dict()} 생성자}
\begin{examplebox}
\begin{lstlisting}
d = dict(name="Potato", age=20)
print(d)
\end{lstlisting}

출력 결과:
\begin{verbatim}
{'name': 'Potato', 'age': 20}
\end{verbatim}
\end{examplebox}

\subsection{딕셔너리 활용하기}

\subsubsection{값 추가 및 수정}
딕셔너리는 \textbf{뮤터블(mutable)} 자료형입니다.
따라서 키에 값을 할당하는 방식으로
새로운 항목을 추가하거나 기존 값을 수정할 수 있습니다.

\begin{examplebox}
\begin{lstlisting}
d = {"a": 1, "b": 2}

d["c"] = 3      # add
d["a"] = 100    # update

print(d)
\end{lstlisting}

출력 결과:
\begin{verbatim}
{'a': 100, 'b': 2, 'c': 3}
\end{verbatim}
\end{examplebox}

\subsubsection{키 존재 여부 확인}
키가 없는데 접근하면 \texttt{KeyError}가 발생합니다.

\begin{examplebox}
\begin{lstlisting}
d = {"a": 1}
print(d["b"])
\end{lstlisting}

출력 결과:
\begin{verbatim}
KeyError: 'b'
\end{verbatim}
\end{examplebox}

따라서 다음과 같이
\textbf{\texttt{in}} 연산자로 키 존재 여부를 확인하는 습관이 중요합니다.

\begin{examplebox}
\begin{lstlisting}
d = {"a": 1}

if "b" in d:
    print(d["b"])
else:
    print("no key")
\end{lstlisting}

출력 결과:
\begin{verbatim}
no key
\end{verbatim}
\end{examplebox}

\subsubsection{\texttt{get(key, default)}}
\begin{conceptbox}
\texttt{get(key, default)}는 키가 존재하면 해당 값을 반환하고,
키가 존재하지 않으면 \texttt{default}를 반환합니다.
\texttt{default}를 생략하면 \texttt{None}을 반환합니다.
\end{conceptbox}

\begin{examplebox}
\begin{lstlisting}
d = {"a": 1}
print(d.get("a"))
print(d.get("b"))
print(d.get("b", 0))
\end{lstlisting}

출력 결과:
\begin{verbatim}
1
None
0
\end{verbatim}
\end{examplebox}

\subsubsection{딕셔너리 순회하기}
딕셔너리는 기본적으로 키를 순회합니다.

\begin{examplebox}
\begin{lstlisting}
d = {"a": 1, "b": 2}

for k in d:
    print(k, d[k])
\end{lstlisting}
\end{examplebox}

또한 \texttt{items()}, \texttt{keys()}, \texttt{values()}를 사용하면
원하는 형태로 순회할 수 있습니다.

\begin{examplebox}
\begin{lstlisting}
for k, v in d.items():
    print(k, v)

for k in d.keys():
    print(k)

for v in d.values():
    print(v)
\end{lstlisting}
\end{examplebox}

\subsection{딕셔너리 자료형 메서드}

\subsubsection{\texttt{keys()}, \texttt{values()}, \texttt{items()}}
\begin{conceptbox}
\texttt{keys()}는 키들의 뷰(view)를,
\texttt{values()}는 값들의 뷰(view)를,
\texttt{items()}는 (키, 값) 쌍들의 뷰(view)를 반환합니다.
\end{conceptbox}

\begin{notebox}
딕셔너리의 \texttt{keys()/values()/items()}는
리스트를 반환하는 것이 아니라 \textbf{뷰(view)}를 반환합니다.
뷰는 원본 딕셔너리가 바뀌면 같이 반영됩니다.
필요하다면 \texttt{list(d.keys())}처럼 리스트로 변환할 수 있습니다.
\end{notebox}

\subsubsection{\texttt{pop(key[, default])}}
\begin{conceptbox}
\texttt{pop(key)}는 \texttt{key}에 해당하는 값을 제거하면서 반환합니다.
키가 없으면 \texttt{KeyError}가 발생하며,
\texttt{default}를 주면 키가 없을 때 \texttt{default}를 반환합니다.
\end{conceptbox}

\begin{examplebox}
\begin{lstlisting}
d = {"a": 1, "b": 2}
x = d.pop("a")
print(x)
print(d)
\end{lstlisting}

출력 결과:
\begin{verbatim}
1
{'b': 2}
\end{verbatim}
\end{examplebox}

\subsubsection{\texttt{update(other)}}
\begin{conceptbox}
\texttt{update(other)}는 다른 딕셔너리(또는 키-값 쌍)를 병합합니다.
같은 키가 있으면 값이 덮어써집니다.
\end{conceptbox}

\begin{examplebox}
\begin{lstlisting}
d = {"a": 1}
d.update({"a": 99, "b": 2})
print(d)
\end{lstlisting}

출력 결과:
\begin{verbatim}
{'a': 99, 'b': 2}
\end{verbatim}
\end{examplebox}

\subsection{딕셔너리에서 키(key)의 조건}
\begin{conceptbox}
딕셔너리의 키는 \textbf{해시 가능(hashable)}해야 합니다.
즉, 일반적으로 \textbf{불변(immutable)} 자료형만 키로 사용할 수 있습니다.
\end{conceptbox}

\begin{examplebox}
\begin{lstlisting}
d = {}
d[(1, 2)] = "point"   # tuple is ok
print(d)
\end{lstlisting}
\end{examplebox}

\begin{examplebox}
\begin{lstlisting}
d = {}
d[[1, 2]] = "bad"     # list is not hashable
\end{lstlisting}

출력 결과:
\begin{verbatim}
TypeError: unhashable type: 'list'
\end{verbatim}
\end{examplebox}

\begin{exercisebox}
\begin{enumerate}
    \item \texttt{d["x"]}와 \texttt{d.get("x")}의 차이점을 설명해보세요.
    \vspace{1.0cm}
    \item 다음 코드의 실행 결과를 예측해보세요.
\begin{verbatim}
d = {"a": 1}
d["b"] = d.get("b", 0) + 1
d["a"] = d.get("a", 0) + 1
print(d)
\end{verbatim}
    \vspace{1.0cm}
    \item 딕셔너리의 키로 리스트를 사용할 수 없는 이유를 ``해시 가능'' 개념을 사용해 설명해보세요.
\end{enumerate}
\end{exercisebox}

\begin{readernotebox}
딕셔너리의 핵심 개념(키-값, KeyError, get, 키의 조건)을 정리해보세요.
\end{readernotebox}