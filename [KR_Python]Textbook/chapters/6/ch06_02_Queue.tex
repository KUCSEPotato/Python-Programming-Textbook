% =========================================================
\section{큐(Queue)}

큐(Queue)는
\textbf{들어온 순서대로 데이터가 처리되는}
자료 구조입니다.

스택이 후입선출(LIFO) 구조였다면,
큐는 그와 반대로
\textbf{선입선출(FIFO: First In, First Out)} 구조를 가집니다.

\begin{conceptbox}
큐(Queue)는
\textbf{먼저 들어온 데이터가 먼저 나가는}
선입선출(FIFO) 방식의 자료 구조입니다.
\end{conceptbox}

현실 세계의 예시는 다음과 같습니다.

\begin{itemize}
    \item 은행 창구 대기 줄
    \item 프린터 출력 대기열
    \item 운영체제의 작업 스케줄링
\end{itemize}

% ---------------------------------------------------------
\subsection{큐의 기본 연산}

큐(Queue)는 다음과 같은 기본 연산들을 제공합니다.

\begin{conceptbox}
\begin{itemize}
    \item \textbf{init} : 큐를 초기화합니다.
    \item \textbf{enqueue} : 큐의 뒤(rear)에 데이터를 추가합니다.
    \item \textbf{dequeue} : 큐의 앞(front)에서 데이터를 제거하고 반환합니다.
    \item \textbf{peek} : 큐의 맨 앞(front)에 있는 데이터를 제거하지 않고 확인합니다.
    \item \textbf{isEmpty} : 큐가 비어 있는지 확인합니다.
    \item \textbf{isFull} : 큐가 가득 찼는지 확인합니다.
    \item \textbf{size} : 큐에 저장된 데이터의 개수를 반환합니다.
\end{itemize}
\end{conceptbox}

% ---------------------------------------------------------
\subsection{리스트로 큐를 구현할 때의 문제점}

리스트를 사용해 큐를 구현하면 다음과 같이 작성할 수 있습니다.

\begin{examplebox}
\begin{lstlisting}
queue = []

queue.append(10)
queue.append(20)
queue.append(30)

print(queue.pop(0))
\end{lstlisting}

출력 결과(예시):
10
\end{examplebox}

하지만 \texttt{pop(0)}은
\textbf{리스트의 모든 요소를 한 칸씩 이동}시켜야 하므로
시간복잡도가 $O(n)$ 입니다.
따라서 리스트는 \textbf{큐 구현에 적합하지 않습니다}.

% ---------------------------------------------------------
\subsection{\texttt{collections.deque}로 큐 구현}

Python에서는
\texttt{collections.deque} 자료형을 사용하여
\textbf{효율적인 큐(queue)}를 구현할 수 있습니다.

\texttt{deque}는
\textbf{double-ended queue}의 줄임말로,
앞(front)과 뒤(rear) 양쪽에서
\textbf{데이터의 삽입과 삭제가 모두 빠르게 수행되는 자료형}입니다.

\begin{conceptbox}
\texttt{deque}는
\begin{itemize}
    \item 앞과 뒤에서의 삽입/삭제가 모두 \textbf{O(1)} 시간 복잡도를 가지며
    \item 큐(FIFO), 덱(양방향 큐) 모두에 적합한 자료 구조입니다.
\end{itemize}
따라서 Python에서 큐를 구현할 때
\texttt{list}보다 \texttt{deque}를 사용하는 것이 일반적으로 권장됩니다.
\end{conceptbox}

\subsubsection{\texttt{deque}를 사용하는 이유}

리스트(\texttt{list})로도 큐를 흉내 낼 수는 있지만,
앞서 언급한 것 처럼 리스트의 맨 앞에서 데이터를 삭제하는 연산은\textbf{O(n)}의 시간 복잡도를 가집니다.

반면 \texttt{deque}는
이러한 이동이 필요 없도록 설계되어 있어,
큐 연산에 훨씬 적합합니다.

\subsubsection{\texttt{deque} 임포트하기}

\texttt{deque}를 사용하려면
\texttt{collections} 모듈에서 불러와야 합니다.

\begin{examplebox}
\begin{lstlisting}
from collections import deque
\end{lstlisting}
\end{examplebox}

\begin{notebox}
\texttt{import}는
외부 모듈에 정의된 기능을 가져오는 문법입니다.
모듈과 임포트의 개념은
다음 챕터에서 자세히 다룹니다.
\end{notebox}

\subsubsection{기본 큐 연산 예제}

\begin{examplebox}
\begin{lstlisting}
from collections import deque

queue = deque()

# enqueue
queue.append(1)
queue.append(2)
queue.append(3)

# peek
print(queue[0])

# dequeue
print(queue.popleft())
print(queue.popleft())

print(queue)
\end{lstlisting}

출력 결과(예시):
\begin{verbatim}
1
1
2
deque([3])
\end{verbatim}
\end{examplebox}

위 예제에서 사용된 연산은 다음과 같은 의미를 가집니다.

\begin{itemize}
    \item \texttt{append(x)} : 큐의 뒤(rear)에 데이터 삽입 (enqueue)
    \item \texttt{popleft()} : 큐의 앞(front)에서 데이터 제거 (dequeue)
    \item \texttt{queue[0]} : 큐의 맨 앞 요소 확인 (peek)
\end{itemize}

\begin{notebox}
\texttt{deque}의 \texttt{append()}와 \texttt{popleft()}는
모두 $O(1)$ 시간에 수행됩니다.
\end{notebox}