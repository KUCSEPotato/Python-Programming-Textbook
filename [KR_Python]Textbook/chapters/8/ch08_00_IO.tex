% =========================================================
\chapter{입력과 출력 (Input \& Output)}

프로그램은
외부로부터 데이터를 입력받고,
처리한 결과를 다시 외부로 출력하는 과정을 반복합니다.
이러한 과정을 통틀어
\textbf{입력과 출력(Input / Output, I/O)}이라고 부릅니다.

출력은 단순히 화면에 값을 표시하는 것일 수도 있고,
파일에 데이터를 저장하거나,
다른 프로그램과 데이터를 주고받기 위한 준비 단계일 수도 있습니다.
이 장에서는
파이썬에서 데이터를 \textbf{표현하고, 출력하고, 보기 좋게 포매팅하는 방법}을
체계적으로 정리합니다.

\begin{notebox}
이 장에는 Chapter 2 자료형에서 이미 다루었던 내용이 일부 포함되어 있습니다.
이미 익숙한 내용이라 하더라도,
출력과 관련된 맥락 속에서 다시 정리해 보시면
이해가 더욱 탄탄해질 것입니다.
\end{notebox}

% ---------------------------------------------------------
\section{출력의 기본}

지금까지 가장 많이 사용한 출력 방법은
\texttt{print()} 함수입니다.

\begin{examplebox}
\begin{lstlisting}
x = 3
y = 5
print(x, y)
\end{lstlisting}

출력 결과(예시):
\begin{verbatim}
3 5
\end{verbatim}
\end{examplebox}

\texttt{print()}는
여러 값을 자동으로 문자열로 변환한 뒤
기본적으로 공백(\texttt{" "})으로 구분하여 출력합니다.
간단한 디버깅이나 확인 용도로는 충분하지만,
출력 형식을 세밀하게 제어하기에는 한계가 있습니다.

\subsection{\texttt{print()}의 핵심 옵션: \texttt{sep}, \texttt{end}}

\texttt{print()}는 출력의 기본 형태를 바꿀 수 있도록
두 가지 중요한 옵션을 제공합니다.

\begin{itemize}
  \item \texttt{sep}: 여러 값을 출력할 때 값 사이에 넣을 구분자
  \item \texttt{end}: 출력의 마지막에 붙일 문자열 (기본은 줄바꿈 \texttt{"\textbackslash n"})
\end{itemize}

\begin{examplebox}
\begin{lstlisting}
print(1, 2, 3, sep="-")
print("Hello", end=" ")
print("World")
\end{lstlisting}

출력 결과(예시):
\begin{verbatim}
1-2-3
Hello World
\end{verbatim}
\end{examplebox}

\begin{notebox}
\texttt{end=""}를 사용하면 줄바꿈 없이 이어서 출력할 수 있습니다.
이는 진행 상황 표시(progress)나 한 줄 갱신 출력 등에 자주 활용됩니다.
\end{notebox}

\subsection{출력 포매팅이 필요한 상황}

예를 들어, 다음과 같은 요구를 생각해봅시다.

\begin{itemize}
  \item 실수 값을 소수점 몇 자리까지만 출력하고 싶을 때
  \item 숫자들을 표 형태로 정렬하고 싶을 때
  \item 문자열과 변수 값을 자연스럽게 섞어 출력하고 싶을 때
  \item 디버깅용으로 ``변수 이름=값'' 형태로 빠르게 출력하고 싶을 때
\end{itemize}

이러한 요구를 만족시키기 위해
파이썬은 여러 가지 문자열 포매팅 방식을 제공합니다.

이번 장에서는 다음 내용을 다룹니다.

\begin{itemize}
  \item f-문자열(포맷 문자열 리터럴)
  \item \texttt{str()}과 \texttt{repr()}의 차이
  \item \texttt{format()} 메서드
  \item 수동 포매팅(\texttt{rjust()} 등)
  \item 옛 포매팅(\texttt{\%}) 방식의 의미와 한계
\end{itemize}

% ---------------------------------------------------------
\section{포맷 문자열 리터럴 (f-문자열)}

가장 권장되는 출력 포매팅 방식은
\textbf{포맷 문자열 리터럴},
즉 \textbf{f-문자열}입니다.

\begin{conceptbox}
f-문자열은
문자열 앞에 \texttt{f} 또는 \texttt{F}를 붙이고,
\texttt{\{ \}} 안에 파이썬 표현식을 작성하여
해당 표현식의 값을 문자열에 삽입하는 방식입니다.
\end{conceptbox}

f-문자열이 강력한 이유는 단순히 ``값을 끼워 넣는 것''을 넘어
\textbf{표현식 자체를 그대로 쓸 수 있다}는 점입니다.

\begin{examplebox}
\begin{lstlisting}
year = 2016
event = "Referendum"
print(f"Results of the {year} {event}")
\end{lstlisting}

출력 결과(예시):
\begin{verbatim}
Results of the 2016 Referendum
\end{verbatim}
\end{examplebox}

위 예제에서 주목할 부분은
\texttt{f"Results of the \{year\} \{event\}"} 부분입니다.

문자열 앞에 붙은 \texttt{f}는
이 문자열이 ``포맷 문자열 리터럴''임을 의미합니다.
중괄호 \texttt{\{ \}} 안에 들어간 표현식은
문자열이 만들어질 때 평가되어
그 결과 값이 문자열 안에 삽입됩니다.

즉,
\texttt{\{year\}}는 변수 \texttt{year}의 값인 \texttt{2016}으로,
\texttt{\{event\}}는 변수 \texttt{event}의 값인 \texttt{"Referendum"}으로
자동 치환됩니다.

\begin{notebox}
\texttt{\{ \}} 안에는 변수뿐 아니라
\texttt{a+b}, \texttt{len(x)} 같은 표현식도 올 수 있습니다.
다만 너무 복잡한 표현식이 들어가면 오히려 읽기 어려워질 수 있습니다.
\end{notebox}

% ---------------------------------------------------------
\section{숫자 포매팅}

실수 출력에서 가장 자주 등장하는 요구는
``소수점 아래 몇 자리까지 출력할 것인가''입니다.
이때 f-문자열의 \textbf{포맷 스펙(format specification)}을 사용할 수 있습니다.

f-문자열에서는
\texttt{\{표현식:포맷지정자\}} 형태로
출력 형식을 제어합니다.

소수점 자리를 지정하려면
\texttt{.nf} 형식을 사용합니다.
여기서 \texttt{n}은 소수점 아래에 표시할 자리 수를 의미합니다.
다음 예시를 살펴보겠습니다.

\begin{examplebox}
\begin{lstlisting}
import math
print(f"The value of pi is approximately {math.pi:.3f}.")
\end{lstlisting}

출력 결과(예시):
\begin{verbatim}
The value of pi is approximately 3.142.
\end{verbatim}
\end{examplebox}

여기서 \texttt{:.3f}는
\begin{itemize}
  \item \texttt{:}  → 포맷 지정 시작
  \item \texttt{.3} → 소수점 아래 3자리까지
  \item \texttt{f}  → 고정 소수점(float) 형식
\end{itemize}
을 의미합니다.

\begin{notebox}
포맷 스펙은 처음에는 외우기보다,
``필요할 때 찾아서 쓰는 도구''로 접근하는 것이 좋습니다.
중요한 것은 ``출력을 표준화할 수 있다''는 점입니다.
\end{notebox}

% ---------------------------------------------------------
\section{폭 지정과 정렬}

출력을 표 형태로 정리하고 싶을 때
폭(width)과 정렬(alignment)을 지정할 수 있습니다.
여기서 폭은 전체 출력 칸의 너비를 의미하고,
정렬은 값이 그 칸 안에서 배치되는 방향을 의미합니다.

폭과 정렬은
중괄호 안에서 콜론(:) 뒤에
``포맷 스펙(format specification)''을 작성하는 방식으로 지정합니다.

\begin{conceptbox}
폭 지정과 정렬의 기본 구조는 다음과 같습니다.

\begin{center}
\texttt{\{값:포맷스펙\}}
\end{center}

포맷 스펙의 일반적인 형태는 다음과 같습니다.

\begin{center}
\texttt{\{값:[채움문자][정렬기호][폭][.정밀도][형식]\}}
\end{center}
\end{conceptbox}

\begin{notebox}
처음에는 구조가 길어 보일 수 있지만,
실제로는 각 요소가 명확한 역할을 가지는 단순한 체계입니다.
모든 요소를 항상 사용하는 것은 아니며,
상황에 따라 필요한 부분만 선택적으로 사용합니다.
\end{notebox}

정렬을 지정할 때 사용하는 기호는 다음과 같습니다.

\begin{itemize}
  \item \texttt{<} : 왼쪽 정렬 (left align)
  \item \texttt{>} : 오른쪽 정렬 (right align)
  \item \verb|^| : 가운데 정렬 (center align)
\end{itemize}

\subsection{기본 정렬 규칙}

정렬 기호를 명시하지 않으면
자료형에 따라 기본 정렬 방식이 자동으로 결정됩니다.

\begin{itemize}
  \item 문자열(\texttt{str}) : 기본은 왼쪽 정렬
  \item 숫자(\texttt{int}, \texttt{float}) : 기본은 오른쪽 정렬
\end{itemize}

이러한 기본 규칙은
사람이 읽기 편한 형태를 기준으로 설계되어 있습니다.
문자열은 보통 왼쪽부터 읽기 때문에 왼쪽 정렬이 기본이며,
숫자는 자릿수 비교가 쉽도록 오른쪽 정렬이 기본입니다.

따라서 정렬 기호를 따로 작성하지 않아도,
폭(width)만 지정하면 자료형에 맞는 정렬이 자동으로 적용됩니다.

\begin{examplebox}
\begin{lstlisting}
table = {"Sjoerd": 4127, "Jack": 4098, "Dcab": 7678}
for name, phone in table.items():
    print(f"{name:10} ==> {phone:6d}")
\end{lstlisting}

출력 결과(예시):
\begin{verbatim}
Sjoerd     ==>   4127
Jack       ==>   4098
Dcab       ==>   7678
\end{verbatim}
\end{examplebox}

위 예시에서 중요한 요소는 다음과 같습니다.

\begin{itemize}
  \item \texttt{\{name:10\}}  
        문자열을 폭 10칸에 맞춰 출력합니다.  
        정렬 기호를 지정하지 않았으므로,
        문자열의 기본 규칙에 따라 왼쪽 정렬이 적용됩니다.

  \item \texttt{\{phone:6d\}}  
        정수를 폭 6칸에 맞춰 출력합니다.  
        \texttt{d}는 10진수 정수 형식을 의미하며,
        숫자의 기본 규칙에 따라 오른쪽 정렬이 적용됩니다.
\end{itemize}

\subsection{정렬을 명시적으로 지정하기}

정렬 기호를 직접 지정하면
자료형과 관계없이 원하는 방향으로 배치할 수 있습니다.

\begin{examplebox}
\begin{lstlisting}
name = "Alice"
score = 95

print(f"|{name:<10}|{score:>5}|")
print(f"|{name:^10}|{score:^5}|")
\end{lstlisting}

출력 결과(예시):
\begin{verbatim}
|Alice     |   95|
|  Alice   |  95 |
\end{verbatim}
\end{examplebox}

폭을 10으로 지정했다는 것은
문자열의 길이가 10이 되도록
남는 공간을 기본적으로 공백으로 채운다는 의미입니다.

만약 실제 데이터의 길이가
지정한 폭보다 크다면,
폭은 자동으로 확장됩니다.
즉, 데이터가 잘리지는 않습니다.

이러한 정렬 기능은
여러 줄의 출력 결과를 보기 좋게 정리할 때 매우 유용합니다.
특히 로그 출력이나 표 형태의 결과 정리에서 자주 사용됩니다.

이 외에도 공백이 아닌 다른 문자로 남는 공간을 채울 수 있습니다.

\subsection{채움 문자 지정}

\begin{conceptbox}
채움 문자 지정의 기본 형식은 다음과 같습니다.

\begin{center}
\texttt{\{값:채움문자정렬기호폭\}}
\end{center}

여기서 채움 문자는 반드시
정렬 기호(\texttt{<}, \texttt{>}, \verb|^|) 바로 앞에 와야 하며,
한 글자만 사용할 수 있습니다.
\end{conceptbox}

다음의 예시를 살펴봅시다.

\begin{examplebox}
\begin{lstlisting}
print(f"{'A':*^10}")
print(f"{'Hi':-<8}")
print(f"{42:0>6}")
\end{lstlisting}

출력 결과(예시):
\begin{verbatim}
****A*****
Hi------
000042
\end{verbatim}
\end{examplebox}

주요 요소에 대한 설명은 다음과 같습니다.

\begin{itemize}
  \item \texttt{*}\verb|^|\texttt{10} : 폭 10, 가운데 정렬, 남는 공간을 \texttt{*}로 채움
  \item \texttt{-<8} : 폭 8, 왼쪽 정렬, 남는 공간을 \texttt{-}로 채움
  \item \texttt{0>6} : 폭 6, 오른쪽 정렬, 남는 공간을 \texttt{0}으로 채움
\end{itemize}

특히 숫자에서 \texttt{0}을 채움 문자로 사용하는 방식은
자릿수를 맞추어 정렬할 때 자주 사용됩니다.
예를 들어, 일련번호, 파일 번호, 날짜 표현 등에서
자리 수를 일정하게 유지할 때 매우 유용합니다.

\subsection{실전 예시: 간단한 표 만들기}

폭과 정렬은
로그 출력, 성적표, 통계 결과 정리 등에서 매우 유용합니다.

\begin{examplebox}
\begin{lstlisting}
students = [
    ("Alice", 91.23),
    ("Bob", 88.5),
    ("Charlie", 100)
]

for name, score in students:
    print(f"{name:<10} | {score:7.2f}")
\end{lstlisting}

출력 결과(예시):
\begin{verbatim}
Alice      |   91.23
Bob        |   88.50
Charlie    |  100.00
\end{verbatim}
\end{examplebox}

여기서

\begin{itemize}
  \item \texttt{\{name:<10\}} : 이름을 폭 10칸에 왼쪽 정렬
  \item \texttt{\{score:7.2f\}} : 전체 폭 7칸, 소수점 아래 2자리 실수
\end{itemize}

을 의미합니다.

\begin{notebox}
정렬은 단순히 ``보기 좋음''의 문제가 아닙니다.
정렬된 출력은 데이터 비교를 빠르게 만들고,
디버깅과 결과 분석의 효율을 크게 향상시킵니다.
특히 여러 줄의 숫자 데이터를 다룰 때
정렬은 거의 필수적인 도구입니다.
\end{notebox}

% ---------------------------------------------------------
\section{\texttt{str()}과 \texttt{repr()}}

모든 파이썬 객체는 문자열로 변환될 수 있습니다.
이때 가장 기본적으로 사용되는 함수가
\texttt{str()}과 \texttt{repr()}입니다.

\begin{conceptbox}
\begin{itemize}
  \item \texttt{str(obj)} :
        사람이 읽기 좋은 형태의 문자열 표현
  \item \texttt{repr(obj)} :
        객체를 가능한 한 \textbf{정확하게 표현}한 문자열
\end{itemize}
\end{conceptbox}

이상적으로는 \texttt{repr(obj)}의 결과를 그대로
인터프리터에 입력하면 동일한 객체를 다시 만들 수 있도록
설계되어 있습니다.

\begin{notebox}
이론적으로는 재현 가능(reconstructable)하도록 설계되지만,
모든 객체가 완벽히 재현 가능한 것은 아닙니다.
예를 들어 파일 객체나 네트워크 연결 객체는
단순한 문자열로 완전히 복원할 수 없습니다.
\end{notebox}

다음은 가장 기본적인 예시입니다.

\begin{examplebox}
\begin{lstlisting}
s = "Hello, world"
print(str(s))
print(repr(s))
\end{lstlisting}

출력 결과(예시):
\begin{verbatim}
Hello, world
'Hello, world'
\end{verbatim}
\end{examplebox}

두 출력의 차이를 보면,
\texttt{repr()}은 문자열의 따옴표까지 포함하고 있음을 알 수 있습니다.
이는 해당 값이 ``문자열 객체''임을 더 명확히 보여주기 위함입니다.

\subsection{인터프리터와 print 함수의 차이}

파이썬 인터프리터에서
변수 이름만 입력하면 보이는 출력은
\texttt{repr()}가 사용됩니다.

반면, \texttt{print(obj)}는
기본적으로 \texttt{str(obj)}를 사용합니다.

\begin{examplebox}
\begin{lstlisting}
>>> s = "Hello"
>>> s
\end{lstlisting}

출력 결과(예시):
\begin{verbatim}
'Hello'
\end{verbatim}
\end{examplebox}

이는 인터프리터가
객체의 ``정확한 표현''을 보여주기 위해
\texttt{repr()}을 사용하기 때문입니다.

\begin{notebox}
\verb|>>>|는 파이썬 대화형 인터프리터의
기본 프롬프트(prompt)입니다.
이는 현재 인터프리터가 입력을 받을 준비가 되었음을 의미합니다.
\end{notebox}

\subsection{왜 \texttt{repr()}이 중요한가?}

\texttt{repr()}은
\textbf{자료의 경계(boundary)}를 명확히 보여줍니다.
특히 다음과 같은 상황에서 매우 중요합니다.

\begin{itemize}
  \item 문자열 안에 공백이 포함되어 있을 때
  \item 줄바꿈 문자(\texttt{\textbackslash n})가 포함되어 있을 때
  \item 보이지 않는 제어 문자가 들어 있을 때
\end{itemize}

다음 예시를 살펴봅시다.

\begin{examplebox}
\begin{lstlisting}
s = "A\nB"
print(str(s))
print(repr(s))
\end{lstlisting}

출력 결과(예시):
\begin{verbatim}
A
B
'A\nB'
\end{verbatim}
\end{examplebox}

\texttt{str()} 출력에서는 실제 줄바꿈이 일어나지만,
\texttt{repr()} 출력에서는 \texttt{\textbackslash n}이 그대로 보입니다.
이 차이는 디버깅 상황에서 매우 중요합니다.

\begin{notebox}
디버깅에서는
``보기 좋은 출력''보다
``객체의 정확한 상태를 보여주는 출력''이 더 중요합니다.
이때 \texttt{repr()}가 큰 도움이 됩니다.
\end{notebox}

% 2/14에 수정할 부분.
% ---------------------------------------------------------
\subsection{변환 지정자: \texttt{!s}, \texttt{!r}, \texttt{!a}}

f-문자열에서는 값이 문자열로 변환되는 방식을 직전에 배운 함수들을 활용하여 직접 지정할 수 있습니다.
기본적으로 아무것도 쓰지 않으면 \texttt{str()}가 자동으로 사용됩니다.
직접 지정하는 방볍은 다음과 같습니다.

\begin{itemize}
  \item \texttt{!s} : \texttt{str()}로 변환
  \item \texttt{!r} : \texttt{repr()}로 변환
  \item \texttt{!a} : \texttt{ascii()}로 변환
\end{itemize}

변환 지정자를 사용한 예시를 살펴봅시다.

\begin{examplebox}
\begin{lstlisting}
animals = "eels"
print(f"My hovercraft is full of {animals}.")
print(f"My hovercraft is full of {animals!r}.")
\end{lstlisting}

출력 결과(예시):
\begin{verbatim}
My hovercraft is full of eels.
My hovercraft is full of 'eels'.
\end{verbatim}
\end{examplebox}

위 예시에서
첫 번째 출력은 아무 변환 지정자를 사용하지 않았으므로
\texttt{str()}가 자동으로 적용됩니다.
따라서 문자열의 내용만 그대로 출력됩니다.

두 번째 출력에서는 \texttt{!r}을 사용했기 때문에
\texttt{repr()}가 적용됩니다.
그 결과, 문자열이 따옴표까지 포함된 형태로 출력됩니다.

\texttt{ascii()}는 \texttt{repr()}와 유사하지만,
비 ASCII 문자를 반드시 이스케이프(escape) 형태로 변환한다는 차이가 있습니다.

\begin{examplebox}
\begin{lstlisting}
text = "café"
print(f"{text}")
print(f"{text!a}")
\end{lstlisting}

출력 결과(예시):
\begin{verbatim}
café
'caf\xe9'
\end{verbatim}
\end{examplebox}

위 예시에서 \texttt{é} 문자는 ASCII 문자 집합에 포함되지 않기 때문에,
\texttt{ascii()}는 이를 유니코드 코드 포인트 기반의 이스케이프 형태
(\texttt{\textbackslash x e9})로 변환합니다.

\begin{notebox}
\texttt{!a}는 주로 인코딩 문제를 확인하거나,
로그 파일 등에서 ASCII 안전 출력이 필요할 때 사용됩니다.
일반적인 출력에서는 거의 사용되지 않습니다.
\end{notebox}

\subsection{변환 지정자와 포맷 스펙의 결합}

변환 지정자는 포맷 스펙과 함께 사용할 수 있습니다.

\begin{examplebox}
\begin{lstlisting}
value = "test"
print(f"{value!r:>10}")
\end{lstlisting}

출력 결과(예시):
\begin{verbatim}
    'test'
\end{verbatim}
\end{examplebox}

이 경우의 처리 순서는 다음과 같습니다.

\begin{enumerate}
  \item 먼저 \texttt{!r}에 의해 \texttt{repr(value)}가 호출됩니다.
  \item 그 결과 문자열 \texttt{'test'}에 대해
        폭과 정렬(\texttt{:>10})이 적용됩니다.
\end{enumerate}

즉, \textbf{변환 지정자가 먼저 적용되고,
그 이후 포맷 스펙이 적용됩니다.}

\begin{notebox}
\texttt{!r}을 사용했기 때문에
출력 결과에는 문자열의 따옴표가 포함됩니다.
\end{notebox}

\subsubsection{숫자 예시}

\begin{examplebox}
\begin{lstlisting}
value = 3.14159
print(f"{value!r:>10}")
print(f"{value:>10.2f}")
\end{lstlisting}

출력 결과(예시):
\begin{verbatim}
   3.14159
      3.14
\end{verbatim}
\end{examplebox}

% ---------------------------------------------------------
\section{자기 설명식 표현식 (debug-friendly f-string)}

디버깅 중에는 ``값''뿐 아니라
``변수 이름''도 함께 보고 싶을 때가 많습니다.
이때 \textbf{자기 설명식 표현식(self-documenting expression)}을 사용할 수 있습니다.

\begin{examplebox}
\begin{lstlisting}
bugs = "roaches"
count = 13
area = "living room"
print(f"Debugging {bugs=} {count=} {area=}")
\end{lstlisting}

출력 결과(예시):
\begin{verbatim}
Debugging bugs='roaches' count=13 area='living room'
\end{verbatim}
\end{examplebox}

\texttt{var=} 형태는
\begin{itemize}
  \item 변수 이름
  \item 등호
  \item 값
\end{itemize}
을 자동으로 함께 출력합니다.
이때 값은 기본적으로 \texttt{repr()} 형태로 출력됩니다.

\subsection{포맷 스펙과 함께 사용하기}

자기 설명식 표현식은
정렬이나 숫자 포맷과 함께 사용할 수도 있습니다.

\begin{examplebox}
\begin{lstlisting}
value = 3.141592
print(f"{value=:.2f}")
\end{lstlisting}

출력 결과(예시):
\begin{verbatim}
value=3.14
\end{verbatim}
\end{examplebox}

\begin{notebox}
\texttt{var=} 형태는
짧은 디버깅 출력에 매우 강력합니다.

단, 최종 제출 코드나 배포 코드에서는
체계적인 로그(logging) 시스템을 사용하는 것이 바람직합니다.
\end{notebox}

% ---------------------------------------------------------
\section{문자열 \texttt{format()} 메서드}

f-문자열이 등장하기 이전부터 사용되던 문자열 포매팅 방식이
\texttt{str.format()} 메서드입니다.

\begin{conceptbox}
\texttt{format()}은
문자열 안의 \texttt{\{\}} 자리에
인자로 전달한 값을 순서대로 삽입하는 방식입니다.
\end{conceptbox}

기본 사용 예시는 다음과 같습니다.

\begin{examplebox}
\begin{lstlisting}
print("We are the {} who say {}!".format("knights", "Hi"))
\end{lstlisting}

출력 결과(예시):
\begin{verbatim}
We are the knights who say Hi!
\end{verbatim}
\end{examplebox}

여기서 \texttt{\{\}}는
\texttt{format()}에 전달된 인자들이 들어갈 자리 표시자입니다.

% ---------------------------------------------------------
\subsection{왜 아직도 \texttt{format()}을 알아야 할까?}

오늘날에는 f-문자열이 더 직관적이고 권장되는 방식이지만,
\texttt{format()}은 여전히 다음과 같은 이유로 중요합니다.

\begin{itemize}
  \item f-문자열을 사용할 수 없는 환경(예: Python 3.5 이하 코드)
  \item 오래된 코드베이스에서 매우 자주 등장
  \item 포맷 문자열을 변수로 분리하여 재사용할 때 유리
  \item 문자열을 동적으로 구성해야 하는 경우
\end{itemize}

즉, \texttt{format()}은
과거의 문법이 아니라
여전히 실무에서 자주 마주치는 도구입니다.

% ---------------------------------------------------------
\subsection{위치 인자(Position Arguments)}

\texttt{\{\}} 안에 숫자를 넣으면
인자의 위치를 명시적으로 지정할 수 있습니다.

\begin{examplebox}
\begin{lstlisting}
print("{0} and {1}".format("spam", "eggs"))
print("{1} and {0}".format("spam", "eggs"))
\end{lstlisting}

출력 결과(예시):
\begin{verbatim}
spam and eggs
eggs and spam
\end{verbatim}
\end{examplebox}

\begin{notebox}
숫자를 생략하면
인자가 전달된 순서대로 자동으로 채워집니다.
\end{notebox}

% ---------------------------------------------------------
\subsection{키워드 인자(Keyword Arguments)}

이름을 지정하여 값을 전달할 수도 있습니다.

\begin{examplebox}
\begin{lstlisting}
print("{food} is {adj}".format(food="spam", adj="horrible"))
\end{lstlisting}

출력 결과(예시):
\begin{verbatim}
spam is horrible
\end{verbatim}
\end{examplebox}

이 방식은
많은 값이 있을 때 가독성을 높여 줍니다.

% ---------------------------------------------------------
\subsection{포맷 스펙 사용하기}

f-문자열에서 배운 포맷 스펙은
\texttt{format()}에서도 동일하게 사용할 수 있습니다.

\begin{examplebox}
\begin{lstlisting}
import math
print("Pi is approximately {:.3f}".format(math.pi))
print("{:>10}".format("Alice"))
\end{lstlisting}

출력 결과(예시):
\begin{verbatim}
Pi is approximately 3.142
     Alice
\end{verbatim}
\end{examplebox}

즉,

\begin{center}
\texttt{\{값:포맷스펙\}}
\end{center}

이라는 구조는
f-문자열과 \texttt{format()}에서 동일하게 작동합니다.

\begin{notebox}
가능하다면 f-문자열을 사용하는 것이 일반적으로 더 읽기 쉽습니다.
하지만 \texttt{format()}을 이해하고 있으면
기존 코드 분석과 유지보수에 큰 도움이 됩니다.
\end{notebox}

% ---------------------------------------------------------
\section{수동 문자열 포매팅}

문자열 메서드를 이용해
출력을 직접 제어할 수도 있습니다.

이 방식은
``가능은 하지만 불편하다''에 가깝고,
주로 기존 코드나 특수한 상황에서 접하게 됩니다.

여기서 ``수동''이라는 표현은,
포맷 스펙을 사용하는 대신
문자열 메서드를 직접 호출해
정렬과 폭을 조정한다는 의미입니다.

\begin{examplebox}
\begin{lstlisting}
for x in range(1, 6):
    print(repr(x).rjust(2), repr(x * x).rjust(4))
\end{lstlisting}

출력 결과(예시):
\begin{verbatim}
 1    1
 2    4
 3    9
 4   16
 5   25
\end{verbatim}
\end{examplebox}

위 코드에서 중요한 부분은 다음과 같습니다.

\begin{itemize}
  \item \texttt{repr(x)}  
        숫자를 문자열로 변환

  \item \texttt{rjust(2)}  
        전체 폭을 2칸으로 맞추고,
        남는 공간을 왼쪽에 공백으로 채움
\end{itemize}

\subsection{자주 사용되는 문자열 정렬 메서드}

\begin{itemize}
  \item \texttt{rjust(width)} : 오른쪽 정렬
  \item \texttt{ljust(width)} : 왼쪽 정렬
  \item \texttt{center(width)} : 가운데 정렬
\end{itemize}

두 번째 인자를 지정하면
채움 문자를 직접 지정할 수도 있습니다.

\begin{examplebox}
\begin{lstlisting}
print("A".rjust(5, "*"))
print("A".center(5, "-"))
\end{lstlisting}

출력 결과(예시):
\begin{verbatim}
****A
--A--
\end{verbatim}
\end{examplebox}

\begin{notebox}
문자열 메서드는 간단한 정렬에는 유용하지만,
복잡한 출력 포맷이나 숫자 정밀도 지정 등은
f-문자열이나 \texttt{format()} 방식이 더 직관적이고 강력합니다.
\end{notebox}

% ---------------------------------------------------------
\section{옛 문자열 포매팅 (\texttt{\%})}

\texttt{\%} 포매팅은
C 언어 스타일에서 유래한
오래된 문자열 포매팅 방식입니다.

오늘날에는 f-문자열이 더 권장되지만,
과거 코드나 일부 라이브러리에서
여전히 등장하므로 의미를 이해할 필요는 있습니다.

\subsection{기본 사용법}

\begin{examplebox}
\begin{lstlisting}
import math
print("The value of pi is approximately %5.3f." % math.pi)
\end{lstlisting}

출력 결과(예시):
\begin{verbatim}
The value of pi is approximately 3.142.
\end{verbatim}
\end{examplebox}

위 예시에서

\begin{itemize}
  \item \texttt{\%f} : 실수(float) 형식
  \item \texttt{5.3f} :
        전체 폭 5칸, 소수점 이하 3자리
\end{itemize}

을 의미합니다.

형식 지정자는 문자열 안에 작성하고,
오른쪽에 오는 값이 \texttt{\%} 연산자를 통해 대입됩니다.

\subsection{여러 값 포매팅}

여러 값을 출력할 때는
튜플로 묶어서 전달합니다.

\begin{examplebox}
\begin{lstlisting}
name = "Alice"
score = 95

print("Name: %s, Score: %d" % (name, score))
\end{lstlisting}

출력 결과(예시):
\begin{verbatim}
Name: Alice, Score: 95
\end{verbatim}
\end{examplebox}

\subsection{자주 쓰이는 형식 지정자}

\begin{itemize}
  \item \texttt{\%s} : 문자열 (str)
  \item \texttt{\%d} : 정수 (decimal integer)
  \item \texttt{\%f} : 실수 (floating point)
\end{itemize}

\begin{notebox}
\texttt{\%} 방식은
\begin{itemize}
  \item 인자가 많아질수록 가독성이 급격히 떨어지고
  \item 순서에 강하게 의존하며
  \item 타입 오류가 런타임에서야 드러나는 단점이 있습니다.
\end{itemize}

따라서 새로운 코드에서는
f-문자열을 사용하는 것이 권장됩니다.
\end{notebox}

% ---------------------------------------------------------
\section{포매팅 방식 선택 가이드}

포매팅 방식은 다양하지만,
초보 단계에서의 선택 기준은 명확합니다.

\begin{itemize}
  \item 기본은 \textbf{f-문자열}
  \item 포맷 문자열을 재사용/조립해야 한다면 \textbf{\texttt{format()}}
  \item 오래된 코드를 읽기 위해 \textbf{\texttt{\%}} 문법을 이해
\end{itemize}

\begin{notebox}
이 장의 핵심은 문법 암기가 아니라,
``출력은 결국 문자열을 만드는 작업''이라는 관점입니다.
출력을 잘 다루면 디버깅도 빨라지고,
프로그램의 품질도 좋아집니다.
\end{notebox}

% ---------------------------------------------------------
\begin{readernotebox}
입력과 출력 단원의 핵심을 스스로 점검해 보세요.
\begin{itemize}
  \item f-문자열이 다른 출력 포매팅 방식보다 권장되는 이유는 무엇인가요?
  \vspace{0.6cm}
  \item \texttt{str()}과 \texttt{repr()}의 차이는 어떤 상황에서 중요해지나요?
  \vspace{0.6cm}
  \item \texttt{sep}과 \texttt{end} 옵션은 언제 유용하게 쓰일까요?
\end{itemize}
\end{readernotebox}